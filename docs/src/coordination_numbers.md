```@meta
CollapsedDocStrings = true
```

# [Coordination numbers](@id coordination_number)

## Extract coordination numbers

The coordination number is the numerical count of how many molecules of a solvent is within a certain distance 
from the solute. The following function provides the functionality of retrieving coordination numbers and atom
groups contributions to these numbers, given a `Result` data structure: 

```@autodocs
Modules = [ComplexMixtures]
Pages = ["coordination_number.jl"]
```

The function can be called without any argument besides the `Result` data structure, in which case the coordination number of the complete solute will 
be returned, as a function of the distance. 

Alternatively, subgroups of the solute or the solvent can be selected, by providing `SoluteGroup` or `SolventGroup` objects as second arguments, 
initialized with the atoms of the subgroup, as a list of indices or a list of atoms generated by `PDBTools`. Note that, if a `SolventGroup`
is defined we obtain the contributions of those solvent atoms to the coordination number *of the solute* (for instance, the sum of the
contributions of all solvent atoms is the coordination number of the solute). 

## Example

In the following example we compute the coordination number of the atoms of `residue 50` (which belongs to the solute - a protein) with the solvent atoms of TMAO, as a function of the distance. The plot produced will show side by side the residue contribution to the MDDF and the corresponding coordination number.

```julia
# Load necessary packages
using ComplexMixtures, PDBTools 
# Load data structure and previously computed results from a mddf calculation 
pdb = read_pdb("test/data/NAMD/structure.pdb")
R = load("test/data/NAMD/protein_tmao.json")
# Define which is the solute
solute = AtomSelection(PDBTools.select(pdb, "protein"), nmols=1)
# We intend to compute the contributions of residue 50 only
residue50 = PDBTools.select(pdb, "residue 50")
# Compute the group contribution to the MDDF
residue50_contribution = contributions(R, SoluteGroup(residue50))
# Now compute the coordination number
residue50_coordination = coordination_number(R, SoluteGroup(residue50))
#
# Plot with twin y-axis
#
using Plots 
plot(R.d, residue50_contribution,
    xaxis="distance / Ã…", 
    yaxis="MDDF contribution", 
    linewidth=2, label=nothing, color=1
)
plot!(twinx(),R.d, residue50_coordination, 
    yaxis="Coordination number", 
    linewidth=2, label=nothing, color=2
)
plot!(title="Residue 50", framestyle=:box, subplot=1)
```

With appropriate input data, this code produces:

```@raw html
<center>
<img width=60% src="../figures/coordination.png" width=80%>
</center>
```
!!! tip
    There are some systems for which the normalization of the distributions is not 
    necessary or possible. It is still possible to compute the coordination numbers,
    by running, instead of `mddf`, the `coordination_number` function:
    ```
    coordination_number(trajectory_file, solute, solvent, options::Options)
    ```
    This call will return a `Result` data structure but with all fields requiring 
    normalization with zeros. In summary, this result
    data structure can be used to compute the coordination numbers, but not the MDDF, RDF, or KB integrals.

!!! compat
    The independent computation of coordination numbers was introduced in version 1.1.
