<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Density maps · ComplexMixtures.jl</title><meta name="title" content="Density maps · ComplexMixtures.jl"/><meta property="og:title" content="Density maps · ComplexMixtures.jl"/><meta property="twitter:title" content="Density maps · ComplexMixtures.jl"/><meta name="description" content="Documentation for ComplexMixtures.jl."/><meta property="og:description" content="Documentation for ComplexMixtures.jl."/><meta property="twitter:description" content="Documentation for ComplexMixtures.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="ComplexMixtures.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="ComplexMixtures.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ComplexMixtures.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../parallel/">Parallel execution</a></li><li><a class="tocitem" href="../quickguide/">Quick Guide</a></li><li><a class="tocitem" href="../examples/">Examples:</a></li><li><a class="tocitem" href="../example1/">◦ Protein in water/glycerol</a></li><li><a class="tocitem" href="../example2/">◦ Polyacrylamide in DMF</a></li><li><a class="tocitem" href="../example3/">◦ POPC membrane in water/ethanol</a></li><li><a class="tocitem" href="../example4/">◦ Water/Glycerol mixture</a></li><li><a class="tocitem" href="../selection/">Set solute and solvent</a></li><li><a class="tocitem" href="../mddf/">Computing the MDDF</a></li><li><a class="tocitem" href="../results/">Results</a></li><li><a class="tocitem" href="../contributions/">Atomic and group contributions</a></li><li><a class="tocitem" href="../save/">Save and load</a></li><li><a class="tocitem" href="../multiple/">Multiple trajectories</a></li><li><a class="tocitem" href="../options/">Options</a></li><li class="is-active"><a class="tocitem" href>Density maps</a><ul class="internal"><li><a class="tocitem" href="#2D_per_residue"><span>2D density map per residue</span></a></li><li><a class="tocitem" href="#grid3D"><span>3D density map around a macromolecule</span></a></li></ul></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../python/">From Python</a></li><li><a class="tocitem" href="../updating_scripts/">Updating scripts</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Density maps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Density maps</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/ComplexMixtures.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/ComplexMixtures.jl/blob/main/docs/src/density_maps.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="density_maps"><a class="docs-heading-anchor" href="#density_maps">Density maps</a><a id="density_maps-1"></a><a class="docs-heading-anchor-permalink" href="#density_maps" title="Permalink"></a></h1><ul><li><a href="#2D_per_residue">2D density map per residue</a></li><li><a href="#grid3D">3D density map around a macromolecule</a></li></ul><h2 id="2D_per_residue"><a class="docs-heading-anchor" href="#2D_per_residue">2D density map per residue</a><a id="2D_per_residue-1"></a><a class="docs-heading-anchor-permalink" href="#2D_per_residue" title="Permalink"></a></h2><ul><li><a href="#The-ResidueContributions-object">The <code>ResidueContributions</code> object</a></li><li><a href="#Contributions-of-subgroups-of-residues">Contributions of subgroups of residues</a></li><li><a href="#Indexing,-slicing,-arithmetic-operations">Indexing, slicing, arithmetic operations</a></li><li><a href="#Saving-and-loading-a-ResidueContributions-object">Saving and loading a ResidueContributions object</a></li></ul><h3 id="The-ResidueContributions-object"><a class="docs-heading-anchor" href="#The-ResidueContributions-object">The <code>ResidueContributions</code> object</a><a id="The-ResidueContributions-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-ResidueContributions-object" title="Permalink"></a></h3><p>One nice way to visualize the accumulation or depletion of a solvent around a macromolecule (a protein, for example), is to obtain a 2D map of the density as a function of the distance from its surface. For example, in the figure below the density of a solute (here, Glycerol), in the neighborhood of a protein is shown:</p><center>
<img src="../figures/density.png" width=80%>
</center><p>Here, one can see that Glycerol accumulates on Asp76 and on the proximity of hydrogen-bonding residues (Serine residues mostly). This figure was obtained by extracting from atomic contributions of the protein the contribution of each residue to the MDDF, coordination numbers or minimum-distance counts. </p><p>The computation of the contributions of each residue can be performed with the convenience function <code>ResidueContributions</code>, which creates an object containing the contributions of the residues to the mddf (or coordination numbers, or minimum-distance counts), the  residue names, and distances:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexMixtures.ResidueContributions" href="#ComplexMixtures.ResidueContributions"><code>ComplexMixtures.ResidueContributions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ResidueContributions (data structure)</code></pre><p><strong>Constructor function:</strong></p><pre><code class="nohighlight hljs">ResidueContributions(
    results::Result, atoms::AbstractVector{&lt;:PDBTools.Atom};
    dmin=1.5, dmax=3.5,
    type=:mddf,
)</code></pre><p>Compute the residue contributions to the solute-solvent pair distribution function. The function returns a <code>ResidueContributions</code> object that can be used to plot the residue contributions, or to perform arithmetic operations with other <code>ResidueContributions</code> objects.</p><p><strong>Arguments</strong></p><ul><li><code>results::Result</code>: The result object obtained from the <code>mddf</code> function.</li><li><code>atoms::AbstractVector{&lt;:PDBTools.Atom}</code>: The vector of atoms of the solute, or a part of it.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>dmin::Float64</code>: The minimum distance to consider. Default is <code>1.5</code>.</li><li><code>dmax::Float64</code>: The maximum distance to consider. Default is <code>3.5</code>.</li><li><code>type::Symbol</code>: The type of the pair distribution function (<code>:mddf</code>, <code>:md_count</code>, or <code>:coordination_number</code>). Default is <code>:mddf</code>.</li><li><code>silent::Bool</code>: If <code>true</code>, the progress bar is not shown. Default is <code>false</code>.</li></ul><p>A structure of type <code>ResultContributions</code> can be used to plot the residue contributions to the solute-solvent pair distribution function, using the <code>Plots.contourf</code> function, and to perform arithmetic operations with other <code>ResidueContributions</code> objects,  multiplying or dividing by a scalar, and slicing (see examples below). </p><p>A ResidueContributions object can be saved to a JSON file using the <code>save</code> function, and loaded back using the <code>load</code> function.</p><p><strong>Examples</strong></p><p><strong>Constructing a ResidueContributions object</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ComplexMixtures, PDBTools

julia&gt; using ComplexMixtures.Testing: data_dir; ComplexMixtures._testing_show_method[] = true; # testing mode

julia&gt; atoms = readPDB(data_dir*&quot;/NAMD/Protein_in_Glycerol/system.pdb&quot;);

julia&gt; results = load(data_dir*&quot;/NAMD/Protein_in_Glycerol/protein_glyc.json&quot;);

julia&gt; rc = ResidueContributions(results, select(atoms, &quot;protein&quot;); silent=true)

          Residue Contributions - 274 residues.
     3.51 █     █      █     █            █
     3.27 █              █   █
     3.03 █     █    █       █            █       █       █                █
     2.79 █    ██    █ █ █   █            █      ██          █        █    █
 d   2.55 █ █  ██    █ █ █   █            ██     ██ █  █  █  █  █     █    █
     2.31 █ █  ██    █ ███   █    ██      ██     ██ █  ██ █  ██ █     █    █
     2.07 █ █   █  █ █████   █    ██      ██     ██ █  ██ █  █ ██    █     █
     1.83 █   █ █  █ █████   █    ██      █      ██ █  ██    █ ██     █    █
     1.59
         A1      T33     T66     S98     S130    T162    A194    H226    G258     


julia&gt; save(&quot;residue_contributions.json&quot;, rc)
&quot;ResidueContributions saved in JSON file: residue_contributions.json&quot;

julia&gt; rc = load(&quot;residue_contributions.json&quot;, ResidueContributions);</code></pre><p><strong>Plotting</strong></p><pre><code class="language-julia hljs">using ComplexMixtures, PDBTools, Plots
...
result = mddf(trajectory_file, solute, solvent, options)
rc = ResidueContributions(result, select(atoms, &quot;protein&quot;))
contourf(rc) # plots a contour map</code></pre><p><strong>Slicing</strong></p><p>A slice of the residue contributions returns a new <code>ResidueContributions</code> object with the selected residues:</p><pre><code class="language-julia hljs">using ComplexMixtures, PDBTools, Plots
...
result = mddf(trajectory_file, solute, solvent, options)
rc = ResidueContributions(result, select(atoms, &quot;protein&quot;))
rc_range = rc[10:50] # slice the residue contributions
contourf(rc_range) # plots a contour map of the selected residues</code></pre><p><strong>Single-residue contributions</strong></p><p>When the contributions of a single residue are computed, or a single-residue contribution is retrieved from a <code>ResidueContributions</code> object, the indexing and iteration over that object occurs over the contributions of that residue:</p><pre><code class="language-julia hljs">using ComplexMixtures, PDBTools, Plots
...
result = mddf(trajectory_file, solute, solvent, options)
rc = ResidueContributions(result, select(atoms, &quot;protein&quot;))
rc60 = rc[60] # contributions of residue 60 only
# index and iterate over the contributions of residue 7
rc60[1] # contribution at the first distance (equivalent to first(rc60))
rc60[end] # contribution at the last distance (equivalent to last(rc60))
count(&gt;(0.01), rc60) # number of distances with contributions greater than 0.01
findmax(rc60) # index and value of maximum contribution</code></pre><p>This is particular useful to retrieve the contributions from all residues at a given distance:</p><pre><code class="language-julia hljs">rc = ResidueContributions(result, select(atoms, &quot;protein&quot;))
rc_last_distance = [ c[end] for c in rc ]
# or, equivalently
rc_last_distance = last.(rc)
# index and value of maximum contribution at each distance, for all residues
findmax.(rc60)</code></pre><p><strong>Arithmetic operations</strong></p><pre><code class="language-julia hljs">using ComplexMixtures, PDBTools, Plots
...
# first simulation (for example, low temperature):
result1 = mddf(trajectory_file1, solute, solvent, options)
rc1 = ResidueContributions(result1, select(atoms, &quot;protein&quot;))
# second simulation (for example, high temperature):
result2 = mddf(trajectory_file2, solute, solvent, options)
rc2 = ResidueContributions(result2, select(atoms, &quot;protein&quot;))
# difference of the residue contributions between the two simulations:
rc_diff = rc2 - rc1
contourf(rc_diff) # plots a contour map of the difference
# multiply and divide by scalars
rc3 = 3 * rc1
rc4 = rc2 / 2</code></pre><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>Slicing, indexing, and multiplication and divison by scalars were introduces in v2.7.0. Saving and loading was introduced in v2.8.0. Iterators were introduced in v2.10.0.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/ComplexMixtures.jl/blob/71e9e52337a55bb9e95553ab5291a6c8365f47bf/src/tools/residue_contributions.jl#L6-L148">source</a></section></article><p>The output of <code>ResidueContributions</code> is by default shown as a simple unicode plot:</p><center>
<img src="../figures/ResidueContributions.png" width=60%>
</center><p>The <code>ResidueContribution</code> object can be used to produce a high-quality contour plot using the <code>Plots.contourf</code> (or <code>contour</code>, or <code>heatmap</code>) function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Plots.contourf-Tuple{ResidueContributions}" href="#Plots.contourf-Tuple{ResidueContributions}"><code>Plots.contourf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contourf(
    rc::ResidueContributions; 
    step::Int=1, 
    oneletter=false, 
    xlabel=&quot;Residue&quot;, 
    ylabel=&quot;r / Å&quot;, 
    kargs...
)
contour(rc::ResidueContributions; kargs...)
heatmap(rc::ResidueContributions; kargs...)</code></pre><p>Plot the contribution of each residue to the solute-solvent pair distribution function as a 2D density map. This function requires loading the <code>Plots</code> package. The calling syntax for <code>contour</code> and <code>heatmap</code> is the same as for <code>contourf</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rc::ResidueContributions</code>: The residue contributions to the solute-solvent pair distribution function,  as computed by the <code>ResidueContributions</code> function.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>step</code>: The step of the residue ticks in the x-axis of the plot. Default is 1 or will be set to show at most 50 ticks labels.</li><li><code>oneletter::Bool</code>: Use one-letter residue codes. Default is <code>false</code>. One-letter codes are only available for the 20 standard amino acids.</li><li><code>xlabel</code> and <code>ylabel</code>: Labels for the x and y axes. Default is <code>&quot;Residue&quot;</code> and <code>&quot;r / Å&quot;</code>.</li></ul><p>This function will set color limits and choose the scale automatically. These parameters can be set with the <code>clims</code> and <code>color</code> arguments of <code>Plots.contourf</code>. Other plot customizations can be  done by passing other keyword arguments to this function, which will be passed to <code>Plots.contourf</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ComplexMixtures, Plots, PDBTools

julia&gt; results = load(&quot;mddf.json&quot;)

julia&gt; atoms = readPDB(&quot;system.pdb&quot;, &quot;protein&quot;)

julia&gt; rc = ResidueContributions(results, atoms; oneletter=true)

julia&gt; plt = contourf(rc; step=5)</code></pre><p>This will produce a plot with the contribution of each residue to the solute-solvent pair distribution function, as a contour plot, with the residues in the x-axis and the distance in the y-axis.</p><p>To customize the plot, use the <code>Plot.contourf</code> keyword parameters, for example:</p><pre><code class="language-julia-repl hljs">julia&gt; plt = contourf(rc; step=5, size=(800,400), title=&quot;Title&quot;, clims=(-0.1, 0.1))</code></pre><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>This function requires loading the <code>Plots</code> package.</p><p>Support for all <code>Plots.contourf</code> parameters was introduced in ComplexMixtures v2.6.0, and support for <code>contour</code> and <code>heatmap</code> was introduced in ComplexMixtures v2.11.0. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/ComplexMixtures.jl/blob/71e9e52337a55bb9e95553ab5291a6c8365f47bf/ext/Plotting.jl#L11-L70">source</a></section></article><p>A complete example of its usage can be seen <a href="../example1/#2D-map-example1">here</a>. </p><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>All features described in this section are only available in v2.10.0 or greater.</p></div></div><h3 id="Contributions-of-subgroups-of-residues"><a class="docs-heading-anchor" href="#Contributions-of-subgroups-of-residues">Contributions of subgroups of residues</a><a id="Contributions-of-subgroups-of-residues-1"></a><a class="docs-heading-anchor-permalink" href="#Contributions-of-subgroups-of-residues" title="Permalink"></a></h3><p>Residue contributions can also be computed for subgroups of the residues. For example, as a continuation of the <a href="../example1/#2D-map-example1">protein in glycerol example</a> , one can compute the map of residue contributions, but splitting the contributions of backbone and side-chains of the residues:</p><pre><code class="language-julia hljs">rc_bb = ResidueContributions(
  results, 
  select(protein, &quot;backbone and resnum &gt;= 70 and resnum &lt;= 110&quot;)
)
rc_st = ResidueContributions(
  results, 
  select(protein, &quot;sidechain and resnum &gt;= 70 and resnum &lt;= 110&quot;)
)</code></pre><p>And we plot the difference between these two maps:</p><pre><code class="language-julia hljs">using Plots
contourf(rc_st - rc_bb; oneletter=true)</code></pre><p>obtaining the following figure:</p><center>
<img width=70% src="../assets/scripts/example1/2D-map_st-bb.png">
</center><p>which shows that the side-chains contribute mostly to these densities, except here expectedly, for some Gly residues.</p><h3 id="Indexing,-slicing,-arithmetic-operations"><a class="docs-heading-anchor" href="#Indexing,-slicing,-arithmetic-operations">Indexing, slicing, arithmetic operations</a><a id="Indexing,-slicing,-arithmetic-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing,-slicing,-arithmetic-operations" title="Permalink"></a></h3><p>The <code>ResidueContributions</code> object can be indexes and sliced, for the analysis of the contributions of specific residues or range of residues:</p><pre><code class="language-julia hljs">rc = ResidueContributions(results1, select(atoms, &quot;protein&quot;)); 
rc_7 = rc[7] # contributions of residue 7
rc_range = rc[20:50] # contributions of a range of residues</code></pre><p>Slicing will return a new <code>ResidueContributions</code> object.</p><p>Additionally, these <code>ResidueContributions</code> objects can be subtracted, divided, summed, or multiplied, to compare contributions of residues among different simulations. Typically, if one wants to compare the solvation of residues in two different simulations,  one can do:</p><pre><code class="language-julia hljs"># first simulation (for example, low temperature)
rc1 = ResidueContributions(results1, select(atoms, &quot;protein&quot;)); 

# second simulation (for example, high temperature)
rc2 = ResidueContributions(results2, select(atoms, &quot;protein&quot;));

# difference in residue contributions to solvation
rc_diff = rc2 - rc1

# Plot difference
using Plots
contourf(rc_diff; title=&quot;Density difference&quot;, step=2, colorbar=:left)</code></pre><p>Which will produce a plot similar to the one below (the data of this plot is just illustrative):</p><p>which will return a new <code>ResidueContributions</code> object.</p><center>
<img src="../figures/density2.png" width=70%>
</center><p>Finally, it is also possible to renormalize the contributions by multiplication or division by scalars,</p><pre><code class="language-julia hljs">rc2 = rc / 15
rc2 = 2 * rc</code></pre><p>When the contributions of a single residue are computed, or a single-residue contribution is retrieved from a <code>ResidueContributions</code> object, the indexing and iteration over that object occurs over the contributions of that residue:</p><pre><code class="language-julia hljs">using ComplexMixtures, PDBTools, Plots
...
result = mddf(trajectory_file, solute, solvent, options)
rc = ResidueContributions(result, select(atoms, &quot;protein&quot;))
rc7 = rc[7] # contributions of residue 7
# iterate over the contributions of residue 7
rc7[1] # contribution of the first distance
rc7[end] # contribution of the last distance</code></pre><p>This is particular useful to retrieve the contributions from all residues at a given distance:</p><pre><code class="language-julia hljs">rc = ResidueContributions(result, select(atoms, &quot;protein&quot;))
rc_last_distance = [ r[end] for r in rc ] 
# or, equivalently
rc_last_distance = last.(rc)
# compute the maximum contribution of each residue:
max_c = maximum.(rc)</code></pre><h3 id="Saving-and-loading-a-ResidueContributions-object"><a class="docs-heading-anchor" href="#Saving-and-loading-a-ResidueContributions-object">Saving and loading a ResidueContributions object</a><a id="Saving-and-loading-a-ResidueContributions-object-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-loading-a-ResidueContributions-object" title="Permalink"></a></h3><p>The <code>ResidueContributions</code> object can be saved and loaded for easier data analysis. In particular, this  is important for very large structures, where its computation can be costly. The saving and loading  functions can be use with:</p><pre><code class="language-julia hljs">rc = ResidueContributions(results1, select(atoms, &quot;protein&quot;)); 
# Save rc objecto to a file (json format):
save(&quot;residue_contributions.json&quot;, rc) 
# Load json file into a new rc_loaded object:
rc_loaded = load(&quot;residue_contributions.json&quot;, ResidueContributions)</code></pre><p>Note that the <code>load</code> function requires, as a second argument, the <code>ResidueContributions</code> type, to differentiate the method from the loading of the <code>Result</code> data structure.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexMixtures.load-Tuple{String, Type{ResidueContributions}}" href="#ComplexMixtures.load-Tuple{String, Type{ResidueContributions}}"><code>ComplexMixtures.load</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load(filename::String, ResidueContributions)</code></pre><p>Function to load the residue contributions saved into a JSON file into the <code>ResidueContributions</code> data structure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ComplexMixtures
rc = ResidueContributions(resutls, SoluteGroup(protein))
save(&quot;residue_contributions.json&quot;, rc)
rc = load(&quot;residue_contributions.json&quot;, ResidueContributions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/ComplexMixtures.jl/blob/71e9e52337a55bb9e95553ab5291a6c8365f47bf/src/tools/residue_contributions.jl#L494-L508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexMixtures.save-Tuple{String, ResidueContributions}" href="#ComplexMixtures.save-Tuple{String, ResidueContributions}"><code>ComplexMixtures.save</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save(filename::String, rc::ResidueContributions)</code></pre><p>Save the <code>ResidueContributions</code> object to a JSON file.</p><pre><code class="language-julia hljs">using ComplexMixtures
rc = ResidueContributions(resutls, SoluteGroup(protein))
save(&quot;residue_contributions.json&quot;, rc)
rc = load(&quot;residue_contributions.json&quot;, ResidueContributions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/ComplexMixtures.jl/blob/71e9e52337a55bb9e95553ab5291a6c8365f47bf/src/tools/residue_contributions.jl#L473-L485">source</a></section></article><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>These <code>ResidueContributions</code> methods are convenience functions only. </p><p>Basically, we are extracting the contribution of each residue independently and building a matrix where each row  represents a distance and each column a residue.  Using <code>PDBTools</code>, this can be done with, for example: </p><pre><code class="language-julia hljs">residues = collect(eachresidue(protein))
residue_contributions = zeros(length(R.d),length(residues))
for (i,residue) in pairs(residues)
  c = contributions(results, SoluteGroup(residue)) 
  residue_contributions[:,i] .= c
end</code></pre><p>The above produces a matrix with a number of columns equal to the number of residues and a number of rows equal to the number of MDDF points. That matrix can be plotted as a contour map with adequate plotting software. </p></div></div><h2 id="grid3D"><a class="docs-heading-anchor" href="#grid3D">3D density map around a macromolecule</a><a id="grid3D-1"></a><a class="docs-heading-anchor-permalink" href="#grid3D" title="Permalink"></a></h2><p>Three-dimensional representations of the distribution functions can also be obtained from the MDDF results. These 3D representations are obtained from the fact that the MDDFs can be decomposed into the contributions of each solute atom, and that each point in space is closest to a single solute atom as well. Thus, each point in space can be associated to one solute atom, and the contribution of that atom to the MDDF at the corresponding distance can be obtained.   </p><p>A 3D density map is constructed with the <code>grid3D</code> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexMixtures.grid3D" href="#ComplexMixtures.grid3D"><code>ComplexMixtures.grid3D</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid3D(
    result::Result, atoms, output_file::Union{Nothing,String} = nothing; 
    dmin=1.5, ddax=5.0, step=0.5, silent = false,
)</code></pre><p>This function builds the grid of the 3D density function and fills an array of mutable structures of type Atom, containing the position of the atoms of  grid, the closest atom to that position, and distance. </p><p><code>result</code> is a <code>ComplexMixtures.Result</code> object  <code>atoms</code> is a vector of <code>PDBTools.Atom</code>s with all the atoms of the system.  <code>output_file</code> is the name of the file where the grid will be written. If <code>nothing</code>, the grid is only returned as a matrix. </p><p><code>dmin</code> and <code>dmax</code> define the range of distance where the density grid will be built, and <code>step</code> defines how fine the grid must be. Be aware that fine grids involve usually a very large (hundreds of thousands points).</p><p><code>silent</code> is a boolean to suppress the progress bar.</p><p>The output PDB has the following characteristics:</p><ul><li>The positions of the atoms are grid points. </li><li>The identity of the atoms correspond to the identity of the protein atom contributing to the MDDF at that point (the closest protein atom). </li><li>The temperature-factor column (<code>beta</code>) contains the relative contribution of that atom to the MDDF at the corresponding distance. </li><li>The <code>occupancy</code> field contains the distance itself.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ComplexMixtures, PDBTools

julia&gt; atoms = readPDB(&quot;./system.pdb&quot;);

julia&gt; R = ComplexMixtures.load(&quot;./results.json&quot;);

julia&gt; grid = grid3D(R, atoms, &quot;grid.pdb&quot;);</code></pre><p>Examples of how the grid can be visualized are provided in the user guide of <code>ComplexMixtures</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/ComplexMixtures.jl/blob/71e9e52337a55bb9e95553ab5291a6c8365f47bf/src/tools/grid3D.jl#L1-L42">source</a></section></article><p>The call to <code>grid3D</code> will write an output a PDB file with the grid points, which loaded in a visualization software side-by-side with the protein structure, allows the production of the images shown. The <code>grid.pdb</code> file contains a regular PDB format where: </p><ul><li>The positions of the atoms are grid points. </li><li>The identity of the atoms correspond to the identity of the protein atom contributing to the MDDF at that point (the closest protein atom). </li><li>The temperature-factor column (<code>beta</code>) contains the relative contribution of that atom to the MDDF at the corresponding distance. </li><li>The <code>occupancy</code> field contains the distance itself.</li></ul><p>For example, the distribution function of a hydrogen-bonding liquid solvating a protein will display a characteristic peak at about 1.8Å. The MDDF at that distance can be decomposed into the contributions of all atoms of the protein which were found to form hydrogen bonds to the solvent. A 3D representation of these contributions can be obtained by computing, around a static protein (solute) structure, which are the regions in space which are closer to each atom of the protein. The position in space is then marked with the atom of the protein to which that region &quot;belongs&quot; and with the contribution of that atom to the MDDF at each distance within that region. A special function to compute this 3D distribution is provided here: <code>grid3D</code>. </p><p>This is better illustrated by a graphical representation. In the figure below we see a 3D representation of the MDDF of Glycerol around a protein, computed from a simulation of this protein in a mixture of water and Glycerol. A complete set of files and a script to reproduce this example <a href="../example1/#3D-map-example1">is available here</a>. </p><center>
<img src="../figures/density3D_final.png" width=100%>
</center><p>In the figure on the left, the points in space around the protein are selected with the following properties: distance from the protein smaller than 2.0Å and relative contribution to the MDDF at the corresponding distance of at least 10% of the maximum contribution. Thus, we are selecting the regions of the protein corresponding to the most stable hydrogen-bonding interactions. The color of the points is the contribution to the MDDF, from blue to red. Thus, the most reddish-points corresponds to the regions where the most stable hydrogen bonds were formed. We have marked two regions here, on opposite sides of the protein, with arrows.</p><p>Clicking on those points we obtain which are the atoms of the protein contributing to the MDDF at that region. In particular, the arrow on the right points to the strongest red region, which corresponds to an Aspartic acid. These residues are shown explicitly under the density (represented as a transparent surface) on the figure in the center.   </p><p>The figure on the right displays, overlapped with the hydrogen-bonding residues, the most important contributions to the second peak of the distribution, corresponding to distances from the protein between 2.0 and 3.5Å. Notably, the regions involved are different from the ones forming hydrogen bonds, indicating that non-specific interactions with the protein (and not a second solvation shell) are responsible for the second peak. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../options/">« Options</a><a class="docs-footer-nextpage" href="../tools/">Tools »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 8 December 2024 13:54">Sunday 8 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
