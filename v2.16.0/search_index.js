var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#Primary-citations","page":"References","title":"Primary citations","text":"If this package was useful to you, please cite the following papers:\n\nL. Martínez, ComplexMixtures.jl: Investigating the structure of solutions of complex-shaped molecules from a solvent-shell perspective. J. Mol. Liq. 347, 117945, 2022.  [Full Text]\nL. Martínez, S. Shimizu, Molecular interpretation of preferential interactions in protein solvation: a solvent-shell perspective by means of minimum-distance distribution functions. J. Chem. Theor. Comp. 13, 6358–6372, 2017. [Full Text]","category":"section"},{"location":"references/#Applications-and-examples","page":"References","title":"Applications and examples","text":"A. F. Pereira, L. Martínez, Osmolyte Structural and Thermodynamic Effects Across the Protein Folding Landscape, JACS Au, 2025. [Full Text]. \n\n<a href=\"https://pubs.acs.org/toc/jpcbfk/129/27\"><img style=\"float: right\" src=\"../assets/2025_jpcb_capa.png\" width=\"20%\"></a>\n\nV. Piccoli, L. Martínez, Cation Hydrophobicity Effects on Protein Solvation in Aqueous Ionic Liquids, J. Phys. Chem. B, 129 (27) 6765-6776, 2025. [Full Text]. \nF. C. Ramos, L. Martínez, Molecular dynamics and solvation structures of the β-glucosidase from Humicola insolens (BGHI) in aqueous solutions containing glucose Int. J. Biol. Macromol. 286 (138210) 2025. [Full Text]\nV. Piccoli, L. Martínez, Competitive Effects of Anions on Protein Solvation by Aqueous Ionic Liquids.  J. Phys. Chem. B 128, 7792-7802, 2024. [Full Text]\nA. F. Pereira, L. Martínez, Helical Content Correlations and Hydration Structures of the Folding Ensemble of the B Domain of Protein A. J. Chem. Inf. Model. 64, 3350-3359, 2024. [Full Text]\nA. F. Pereira, V. Piccoli, L. Martínez, Trifluoroethanol direct interactions with protein backbones destabilize alpha-helices.  J. Mol. Liq. 365, 120209, 2022. [Full Text]\nV. Piccoli, L. Martínez, Ionic liquid solvation of proteins in native and denatured states.  J. Mol. Liq. 363, 119953, 2022. [Full Text]\nV. Piccoli, L. Martínez, Correlated counterion effects in the solvation of proteins by ionic-liquids. J. Mol. Liq. 320, 114347, 2020. [Full Text]\nI. P. de Oliveira, L. Martínez, The shift in urea orientation at protein surfaces at low pH is compatible with a direct mechanism of protein denaturation. Phys. Chem. Chem. Phys. 22, 354-367, 2020. [Full Text]\nI. P. de Oliveira, L. Martínez, Molecular basis for competitive solvation of the Burkholderia cepacia lipase by sorbitol and urea. Phys. Chem. Chem. Phys. 18, 21797-21808, 2016. [Full Text]","category":"section"},{"location":"references/#See-also","page":"References","title":"See also","text":"Packmol: A package for building initial configurations for molecular dynamics simulations.\nCellListMap.jl: Efficient and customizable implementation of cell lists, which allows the computation of general properties dependent on distances of particles within a cutoff, for example short-range potentials, forces, neighbor lists, etc.\nMDLovoFit: Automatic identification of mobile and rigid substructures in molecular dynamics simulations and fractional structural fluctuation analysis. ","category":"section"},{"location":"references/#Breaking-changes","page":"References","title":"Breaking changes","text":"The syntax changes necessary to update script from version 1.X to 2.X of  the package are:","category":"section"},{"location":"references/#Atom-selections","page":"References","title":"Atom selections","text":"The previous Selection structure was renamed to AtomSelection for clarity.\n\nBefore:\n\nwater = Selection(water; natomspermol=3)\n\nNow:\n\nwater = AtomSelection(water; natomspermol=3)","category":"section"},{"location":"references/#Group-contributions-syntax","page":"References","title":"Group contributions syntax","text":"The syntax to computing group contributions is improved. Previously, the contrib or contributions functions required three somewhat redundant parameters. \n\nBefore:\n\nThe call to contributions required 3 parameters: the Selection structure, the matrix of contributions, and the indexes of the atoms for which the contributions were desired:\n\nh_contributions = contributions(solvent, R.solvent_atom, h_indexes)\n\nNow:\n\nThe contributions are extracted from the Result data structure, by  providing either a SoluteGroup or SolventGroup object, which are setup with the group names, group indexes, atom names, or atom indexes:\n\nh_contributions = contributions(R, SolventGroup(h_indexes))","category":"section"},{"location":"references/#Frame-weights","page":"References","title":"Frame weights","text":"frame_weights is an option of the mddf execution. That is previously, they were defined in the Options data structure, and now they are passed to the mddf function.\n\nBefore:\n\noptions = Options(frame_weights=[1.0, 2.0], bulk_range=(8.0, 12.0))\nresults = mddf(trajectory_file, solute, solvent, options)\n\nNow:\n\nresults = mddf(trajectory_file, solute, solvent, options; frame_weights=[1.0, 2.0])","category":"section"},{"location":"results/#results","page":"Results","title":"Results","text":"The results of a MDDF calculation are returned in a data structure which contains  the MDDF, KB integrals, and atomic contributions. The following section will assume that the computation was performed by calling the mddf function with \n\nresults = mddf(trajectory_file, solute, solvent, Options(bulk_range=(8.0, 12.0)))\n\nsuch that the results variable contain the Result data structure. By default, the histograms contain 500 bins (binstep=0.002 and cutoff=10.) such that all data-vectors will contain 500 lines.\n\nTo learn how to save and load saved data, read the next section.","category":"section"},{"location":"results/#The-Result-data-structure:-main-data","page":"Results","title":"The Result data structure: main data","text":"The most important data to be read from results are the distances, minimum-distance distribution function, and KB integrals. These data is stored in the following vectors:","category":"section"},{"location":"results/#Distances-of-the-histograms:-results.d","page":"Results","title":"Distances of the histograms: results.d","text":"The following vector will contain values ranging from 0. to cutoff, and the distance at each bin is the distance in that bin for which half of the volume of the bin is within d, and half of the volume is above d, if the volume was spherical: \n\njulia> results.d\n500-element Array{Float64,1}:\n 0.015874010519682\n 0.033019272488946275\n ⋮\n 9.970010030080179\n 9.99001000999998","category":"section"},{"location":"results/#Minimum-distance-distribution-function:-results.mddf","page":"Results","title":"Minimum-distance distribution function: results.mddf","text":"The results.mddf vector will contain the main result, which the minimum-distance distribution function. For a properly-sampled simulation, it will be zero at very short distances and converge to 1.0 for distances smaller than the cutoff:\n\njulia> results.mddf\n500-element Array{Float64,1}:\n 0.0\n 0.0\n     ⋮\n 0.999052514965403\n 1.001030818286187\n\n\nA typical plot of results.mddf as a function of results.d will look like:\n\n<img src=\"../figures/mddf.png\" width=\"60%\">\n\nThus, this plot was obtained with the following code:\n\nusing Plots\nplot(results.d,results.mddf,xlabel=\"d/A\",ylabel=\"mddf(d) / L/mol\") ","category":"section"},{"location":"results/#Kirkwood-Buff-integral:-results.kb","page":"Results","title":"Kirkwood-Buff integral: results.kb","text":"The results.kb vector will contain the Kirkwood-Buff integral computed as a function of the minimum-distance to the solute. For properly sampled simulations, it is expected to converge at large distances.  \n\njulia> results.kb\n500-element Array{Float64,1}:\n     0.0\n    -0.3249356504752985\n    -2.9804719721525\n     ⋮\n    0.72186381783\n    1.13624162115\n\nA typical plot of results.kb as a function of results.d will look like:\n\n<img src=\"../figures/kb.png\" width=\"60%\">\n\nThus, this plot was obtained with the following code:\n\nusing Plots\nplot(\n    results.d, \n    results.kb / 1000, # convert to L / mol\n    xlabel=\"d/A\",\n    ylabel=\"mddf(d) / L/mol\"\n) ","category":"section"},{"location":"results/#Units","page":"Results","title":"Units","text":"The distance is assumed to be in Å, as this is the most common distance units in molecular simulations. The coordinates of the atoms are assumed be provided in Å. \nThe minimum-distance distribution function is unit-less, since it is the ratio of the density at each distance divided by an ideal-gas density.\nThe Kirkwood-Buff integrals are returned in cm³ mol⁻¹, if the coordinates were provided in Å.\n\nwarning: Warning\nIf the coordinates are not in Å, the calculation will  proceed normally, but the units of the KB integrals, which has units of volume per mol, should be converted to conform the length unit provided. Note that all coordinates that are supported by default (and are thus read by the Chemfiles library) will be  in Å, independently on the software used to generate the trajectories, as described here. ","category":"section"},{"location":"results/#Coordination-number-and-other-data","page":"Results","title":"Coordination number and other data","text":"Obtaining the MDDF involves the computation of some intermediate properties that are frequently useful for additional solution structure analysis. In particular, the coordination numbers are computed. For example, the coordination number as a function from the distance to the solute can be retrieved from a Results data structure with:\n\ncoordination_number = results.coordination_number\n\nand this data can be plotted against the distances by:\n\nplot(result.d,results.coordination_number)\n\nThe coordination number of subgroups can also be obtained, as explained in the Coordination number section.\n\nThe complete data available is:\n\nParameter Meaning Type of value Comment\nd Vector of distances of the histograms. Vector{Float64} To be used as the x coordinate on plotting any of the data.\nmd_count Non-normalized count of minimum distances at each d. Vector{Float64} This is the number of minimum distances found at each histogram bin, without normalization. Usually this is not interesting to analyze, because it is dependent on the bin size.\nmd_count_random Number of minimum distances found at each histogram bin for the random distribution. Vector{Float64} This is the normalization required to convert the md_count array into the minimum-distance distribution.\ncoordination_number Cumulative number of sites found for each histogram distance. Vector{Float64} This is the coordination number, that is, the number of sites found cumulative up to each distance, without any normalization.\ncoordination_number_random Cumulative site count for the random distribution. Vector{Float64} Usually not interesting for analysis.\nmddf The final distribution function. Vector{Float64} This is the MDDF computed (md_count normalized by md_count_random). It is the main result of the calculation.\nkb The final Kirkwood-Buff integral. Vector{Float64} This is the final KB integral, as a function of the integration distance from the solute. Computed as coordination_number - coordination_number_random\nsolute_atom Atomic contributions of the solute. Matrix{Float64} This is a matrix with nbins lines and solute.natomspermol columns, containing the atomic contributions of each solute atom to the complete MDDF.\nsolvent_atom Atomic contributions of the solvent. Matrix{Float64} This is a matrix with nbins lines and solvent.natomspermol columns, containing the atomic contributions of each solvent atom to the complete MDDF.\ndensity.solute Density (concentration) of the solute in the complete simulation box. Float64 In units of molecules/textrmAA^3\ndensity.solvent Density (concentration) of the solvent in the complete simulation box. Float64 In units of molecules/textrmAA^3\ndensity.solvent_bulk Density (concentration) of the solute in the bulk region. Float64 In units of molecules/textrmAA^3\nvolume Volume measures. Volume Contains the total volume of the simulation, the bulk volume, the volume of the solute domain and the shell volume of each bin of the histogram. These are computed by numerical integration from the random distributions.\nfiles List of files read. Vector{String} \nweights Weights of each file in the final counts. Vector{Float64} If the trajectories have different lengths or number of frames, the weights are adapted accordingly.\n   ","category":"section"},{"location":"results/#Other-Result-parameters-available-which-are-set-at-Options:","page":"Results","title":"Other Result parameters available which are set at Options:","text":"Parameter Meaning Type of value Comment\nnbins Number of bins of the histograms. Int \ndbulk Distance from solute of bulk solution. Float64 \ncutoff Maximum distance to be considered for histograms. Float64 \nautocorrelation The solute is the same as the solvent? Bool Automatically set if solute == solvent.\nsolute Properties of the solute AtomSelection Contains the number of atoms, number of atoms per molecule and number of molecules of the solute.\nsolvent Properties of the solvent. AtomSelection Contains the number of atoms, number of atoms per molecule and number of molecules of the solvent.\nirefatom This is a reference atom that is used to generate random rotations and translations internally. Int Counts of the distributions for this atom are performed automatically to obtain radial (or proximal) distribution functions. Can be used for testing purposes.\nrdf_count This is the md_count minimum distance count of irefatom. Vector{Float64} This corresponds to the conventional radial distribution function if the solute contains only one atom.\nrdf_count_random Minimum distance of irefatom count for the random distribution. Vector{Float64} \nrdf Distribution function computed from the irefatom distribution. It is a conventional rdf if the solvent has only one atom. Vector{Float64} \nkb_rdf Kirkwood-Buff integral computed from the irefatom distribution. Vector{Float64} This must converge, at long distances, to the same value as kb, and can be used for testing.\noptions Calculation options. Options Carries (some redundant) options set by the user.\nlastframe_read Last frame read from the trajectory. Int \nn_frames_read Number of frames read from the trajectory. Int Can differ from lastframe_read if stride != 1\n   ","category":"section"},{"location":"results/#Reference-functions","page":"Results","title":"Reference functions","text":"","category":"section"},{"location":"results/#ComplexMixtures.Result","page":"Results","title":"ComplexMixtures.Result","text":"mutable struct Result\n\nStructure to contain the results of the MDDF calculation.\n\nVersion::VersionNumber\nnbins::Int64\ndbulk::Float64\ncutoff::Float64\nd::Vector{Float64}\nmd_count::Vector{Float64}\nmd_count_random::Vector{Float64}\ncoordination_number::Vector{Float64}\ncoordination_number_random::Vector{Float64}\nmddf::Vector{Float64}\nkb::Vector{Float64}\nautocorrelation::Bool\nsolute::AtomSelection\nsolvent::AtomSelection\nsolute_group_count::Vector{Vector{Float64}}\nsolvent_group_count::Vector{Vector{Float64}}\nrdf_count::Vector{Float64}\nrdf_count_random::Vector{Float64}\nsum_rdf_count::Vector{Float64}\nsum_rdf_count_random::Vector{Float64}\nrdf::Vector{Float64}\nkb_rdf::Vector{Float64}\ndensity::ComplexMixtures.Density\nvolume::ComplexMixtures.Volume\nfiles::Vector{ComplexMixtures.TrajectoryFileOptions}\nweights::Vector{Float64}\n\nThe Result{Vector{Float64}} parametric type is necessary only for reading the JSON3 saved file. \n\n\n\n\n\n","category":"type"},{"location":"results/#ComplexMixtures.overview-Tuple{Result}","page":"Results","title":"ComplexMixtures.overview","text":"overview(R::Result)\n\nFunction that outputs the volumes and densities in the most natural units.\n\n\n\n\n\n","category":"method"},{"location":"results/#ComplexMixtures.Density","page":"Results","title":"ComplexMixtures.Density","text":"mutable struct Density\n\nStructure to contain the density values obtained from the calculation.\n\nsolute::Float64\nsolvent::Float64\nsolvent_bulk::Float64\n\n\n\n\n\n","category":"type"},{"location":"density_maps/#density_maps","page":"Density maps","title":"Density maps","text":"2D density map per residue\n3D density map around a macromolecule","category":"section"},{"location":"density_maps/#2D_per_residue","page":"Density maps","title":"2D density map per residue","text":"The ResidueContributions object\nContributions of subgroups of residues\nIndexing, slicing, arithmetic operations\nSaving and loading a ResidueContributions object","category":"section"},{"location":"density_maps/#The-ResidueContributions-object","page":"Density maps","title":"The ResidueContributions object","text":"One nice way to visualize the accumulation or depletion of a solvent around a macromolecule (a protein, for example), is to obtain a 2D map of the density as a function of the distance from its surface. For example, in the figure below the density of a solute (here, Glycerol), in the neighborhood of a protein is shown:\n\n<center>\n<img src=\"../figures/density.png\" width=80%>\n</center>\n\nHere, one can see that Glycerol accumulates on Asp76 and on the proximity of hydrogen-bonding residues (Serine residues mostly). This figure was obtained by extracting from atomic contributions of the protein the contribution of each residue to the MDDF, coordination numbers or minimum-distance counts. \n\nThe computation of the contributions of each residue can be performed with the convenience function ResidueContributions, which creates an object containing the contributions of the residues to the mddf (or coordination numbers, or minimum-distance counts), the  residue names, and distances:\n\nThe output of ResidueContributions is by default shown as a simple unicode plot:\n\n<center>\n<img src=\"../figures/ResidueContributions.png\" width=60%>\n</center>\n\nThe ResidueContribution object can be used to produce a high-quality contour plot using the Plots.contourf (or contour, or heatmap) function:\n\nA complete example of its usage can be seen here. \n\ncompat: Compat\nAll features described in this section are only available in v2.10.0 or greater.","category":"section"},{"location":"density_maps/#Contributions-of-subgroups-of-residues","page":"Density maps","title":"Contributions of subgroups of residues","text":"Residue contributions can also be computed for subgroups of the residues. For example, as a continuation of the protein in glycerol example , one can compute the map of residue contributions, but splitting the contributions of backbone and side-chains of the residues:\n\nrc_bb = ResidueContributions(\n  results, \n  select(protein, \"backbone and resnum >= 70 and resnum <= 110\")\n)\nrc_st = ResidueContributions(\n  results, \n  select(protein, \"sidechain and resnum >= 70 and resnum <= 110\")\n)\n\nAnd we plot the difference between these two maps:\n\nusing Plots\ncontourf(rc_st - rc_bb; oneletter=true)\n\nobtaining the following figure:\n\n<center>\n<img width=70% src=\"../assets/scripts/example1/2D-map_st-bb.png\">\n</center>\n\nwhich shows that the side-chains contribute mostly to these densities, except here expectedly, for some Gly residues.","category":"section"},{"location":"density_maps/#Indexing,-slicing,-arithmetic-operations","page":"Density maps","title":"Indexing, slicing, arithmetic operations","text":"The ResidueContributions object can be indexes and sliced, for the analysis of the contributions of specific residues or range of residues:\n\nrc = ResidueContributions(results1, select(atoms, \"protein\")); \nrc_7 = rc[7] # contributions of residue 7\nrc_range = rc[20:50] # contributions of a range of residues\n\nSlicing will return a new ResidueContributions object.\n\nAdditionally, these ResidueContributions objects can be subtracted, divided, summed, or multiplied, to compare contributions of residues among different simulations. Typically, if one wants to compare the solvation of residues in two different simulations,  one can do:\n\n# first simulation (for example, low temperature)\nrc1 = ResidueContributions(results1, select(atoms, \"protein\")); \n\n# second simulation (for example, high temperature)\nrc2 = ResidueContributions(results2, select(atoms, \"protein\"));\n\n# difference in residue contributions to solvation\nrc_diff = rc2 - rc1\n\n# Plot difference\nusing Plots\ncontourf(rc_diff; title=\"Density difference\", step=2, colorbar=:left)\n\nWhich will produce a plot similar to the one below (the data of this plot is just illustrative):\n\nwhich will return a new ResidueContributions object.\n\n<center>\n<img src=\"../figures/density2.png\" width=70%>\n</center>\n\nFinally, it is also possible to renormalize the contributions by multiplication or division by scalars,\n\nrc2 = rc / 15\nrc2 = 2 * rc\n\nWhen the contributions of a single residue are computed, or a single-residue contribution is retrieved from a ResidueContributions object, the indexing and iteration over that object occurs over the contributions of that residue:\n\nusing ComplexMixtures, PDBTools, Plots\n...\nresult = mddf(trajectory_file, solute, solvent, options)\nrc = ResidueContributions(result, select(atoms, \"protein\"))\nrc7 = rc[7] # contributions of residue 7\n# iterate over the contributions of residue 7\nrc7[1] # contribution of the first distance\nrc7[end] # contribution of the last distance\n\nThis is particular useful to retrieve the contributions from all residues at a given distance:\n\nrc = ResidueContributions(result, select(atoms, \"protein\"))\nrc_last_distance = [ r[end] for r in rc ] \n# or, equivalently\nrc_last_distance = last.(rc)\n# compute the maximum contribution of each residue:\nmax_c = maximum.(rc)","category":"section"},{"location":"density_maps/#Saving-and-loading-a-ResidueContributions-object","page":"Density maps","title":"Saving and loading a ResidueContributions object","text":"The ResidueContributions object can be saved and loaded for easier data analysis. In particular, this  is important for very large structures, where its computation can be costly. The saving and loading  functions can be use with:\n\nrc = ResidueContributions(results1, select(atoms, \"protein\")); \n# Save rc objecto to a file (json format):\nsave(\"residue_contributions.json\", rc) \n# Load json file into a new rc_loaded object:\nrc_loaded = load(\"residue_contributions.json\", ResidueContributions)\n\nNote that the load function requires, as a second argument, the ResidueContributions type, to differentiate the method from the loading of the Result data structure.\n\ntip: Tip\nThese ResidueContributions methods are convenience functions only. Basically, we are extracting the contribution of each residue independently and building a matrix where each row  represents a distance and each column a residue.  Using PDBTools, this can be done with, for example: residues = collect(eachresidue(protein))\nresidue_contributions = zeros(length(R.d),length(residues))\nfor (i,residue) in pairs(residues)\n  c = contributions(results, SoluteGroup(residue)) \n  residue_contributions[:,i] .= c\nendThe above produces a matrix with a number of columns equal to the number of residues and a number of rows equal to the number of MDDF points. That matrix can be plotted as a contour map with adequate plotting software. ","category":"section"},{"location":"density_maps/#grid3D","page":"Density maps","title":"3D density map around a macromolecule","text":"Three-dimensional representations of the distribution functions can also be obtained from the MDDF results. These 3D representations are obtained from the fact that the MDDFs can be decomposed into the contributions of each solute atom, and that each point in space is closest to a single solute atom as well. Thus, each point in space can be associated to one solute atom, and the contribution of that atom to the MDDF at the corresponding distance can be obtained.   \n\nA 3D density map is constructed with the grid3D function:\n\nThe call to grid3D will write an output a PDB file with the grid points, which loaded in a visualization software side-by-side with the protein structure, allows the production of the images shown. The grid.pdb file contains a regular PDB format where: \n\nThe positions of the atoms are grid points. \nThe identity of the atoms correspond to the identity of the protein atom contributing to the property at that point (the closest protein atom). \nThe temperature-factor column (beta) contains the relative contribution of that atom to the property at the corresponding distance. \nThe occupancy field contains the distance itself.\n\nThe \"property\" is, by default, the MDDF. Coordination numbers of minimum-distance counts can be used by setting the type keyword parameter.\n\nFor example, the distribution function of a hydrogen-bonding liquid solvating a protein will display a characteristic peak at about 1.8Å. The MDDF at that distance can be decomposed into the contributions of all atoms of the protein which were found to form hydrogen bonds to the solvent. A 3D representation of these contributions can be obtained by computing, around a static protein (solute) structure, which are the regions in space which are closer to each atom of the protein. The position in space is then marked with the atom of the protein to which that region \"belongs\" and with the contribution of that atom to the MDDF at each distance within that region. A special function to compute this 3D distribution is provided here: grid3D. \n\nThis is better illustrated by a graphical representation. In the figure below we see a 3D representation of the MDDF of Glycerol around a protein, computed from a simulation of this protein in a mixture of water and Glycerol. A complete set of files and a script to reproduce this example is available here. \n\n<center>\n<img src=\"../figures/density3D_final.png\" width=100%>\n</center>\n\nIn the figure on the left, the points in space around the protein are selected with the following properties: distance from the protein smaller than 2.0Å and relative contribution to the MDDF at the corresponding distance of at least 10% of the maximum contribution. Thus, we are selecting the regions of the protein corresponding to the most stable hydrogen-bonding interactions. The color of the points is the contribution to the MDDF, from blue to red. Thus, the most reddish-points corresponds to the regions where the most stable hydrogen bonds were formed. We have marked two regions here, on opposite sides of the protein, with arrows.\n\nClicking on those points we obtain which are the atoms of the protein contributing to the MDDF at that region. In particular, the arrow on the right points to the strongest red region, which corresponds to an Aspartic acid. These residues are shown explicitly under the density (represented as a transparent surface) on the figure in the center.   \n\nThe figure on the right displays, overlapped with the hydrogen-bonding residues, the most important contributions to the second peak of the distribution, corresponding to distances from the protein between 2.0 and 3.5Å. Notably, the regions involved are different from the ones forming hydrogen bonds, indicating that non-specific interactions with the protein (and not a second solvation shell) are responsible for the second peak. ","category":"section"},{"location":"density_maps/#ComplexMixtures.ResidueContributions","page":"Density maps","title":"ComplexMixtures.ResidueContributions","text":"ResidueContributions (data structure)\n\nConstructor function:\n\nResidueContributions(\n    results::Result, atoms::AbstractVector{<:PDBTools.Atom};\n    dmin=1.5, dmax=3.5,\n    type=:mddf,\n)\n\nCompute the residue contributions to the solute-solvent pair distribution function. The function returns a ResidueContributions object that can be used to plot the residue contributions, or to perform arithmetic operations with other ResidueContributions objects.\n\nArguments\n\nresults::Result: The result object obtained from the mddf function.\natoms::AbstractVector{<:PDBTools.Atom}: The vector of atoms of the solute, or a part of it.\n\nOptional arguments\n\ndmin::Float64: The minimum distance to consider. Default is 1.5.\ndmax::Float64: The maximum distance to consider. Default is 3.5.\ntype::Symbol: The type of the pair distribution function (:mddf, :md_count, or :coordination_number). Default is :mddf.\nsilent::Bool: If true, the progress bar is not shown. Default is false.\n\nA structure of type ResultContributions can be used to plot the residue contributions to the solute-solvent pair distribution function, using the Plots.contourf function, and to perform arithmetic operations with other ResidueContributions objects,  multiplying or dividing by a scalar, and slicing (see examples below). \n\nA ResidueContributions object can be saved to a JSON file using the save function, and loaded back using the load function.\n\nExamples\n\nConstructing a ResidueContributions object\n\njulia> using ComplexMixtures, PDBTools\n\njulia> using ComplexMixtures: data_dir; ComplexMixtures._testing_show_method[] = true; # testing mode\n\njulia> atoms = read_pdb(data_dir*\"/NAMD/Protein_in_Glycerol/system.pdb\");\n\njulia> results = load(data_dir*\"/NAMD/Protein_in_Glycerol/protein_glyc.json\");\n\njulia> rc = ResidueContributions(results, select(atoms, \"protein\"); silent=true)\n\n          Residue Contributions - 274 residues.\n     3.51 █     █      █     █            █\n     3.27 █              █   █\n     3.03 █     █    █       █            █       █       █                █\n     2.79 █    ██    █ █ █   █            █      ██          █        █    █\n d   2.55 █ █  ██    █ █ █   █            ██     ██ █  █  █  █  █     █    █\n     2.31 █ █  ██    █ ███   █    ██      ██     ██ █  ██ █  ██ █     █    █\n     2.07 █ █   █  █ █████   █    ██      ██     ██ █  ██ █  █ ██    █     █\n     1.83 █   █ █  █ █████   █    ██      █      ██ █  ██    █ ██     █    █\n     1.59\n         A1      T33     T66     S98     S130    T162    A194    H226    G258     \n\n\njulia> save(\"residue_contributions.json\", rc)\n\"ResidueContributions saved in JSON file: residue_contributions.json\"\n\njulia> rc = load(\"residue_contributions.json\", ResidueContributions);\n\nPlotting\n\nusing ComplexMixtures, PDBTools, Plots\n...\nresult = mddf(trajectory_file, solute, solvent, options)\nrc = ResidueContributions(result, select(atoms, \"protein\"))\ncontourf(rc) # plots a contour map\n\nSlicing\n\nA slice of the residue contributions returns a new ResidueContributions object with the selected residues:\n\nusing ComplexMixtures, PDBTools, Plots\n...\nresult = mddf(trajectory_file, solute, solvent, options)\nrc = ResidueContributions(result, select(atoms, \"protein\"))\nrc_range = rc[10:50] # slice the residue contributions\ncontourf(rc_range) # plots a contour map of the selected residues\n\nSingle-residue contributions\n\nWhen the contributions of a single residue are computed, or a single-residue contribution is retrieved from a ResidueContributions object, the indexing and iteration over that object occurs over the contributions of that residue:\n\nusing ComplexMixtures, PDBTools, Plots\n...\nresult = mddf(trajectory_file, solute, solvent, options)\nrc = ResidueContributions(result, select(atoms, \"protein\"))\nrc60 = rc[60] # contributions of residue 60 only\n# index and iterate over the contributions of residue 7\nrc60[1] # contribution at the first distance (equivalent to first(rc60))\nrc60[end] # contribution at the last distance (equivalent to last(rc60))\ncount(>(0.01), rc60) # number of distances with contributions greater than 0.01\nfindmax(rc60) # index and value of maximum contribution\n\nThis is particular useful to retrieve the contributions from all residues at a given distance:\n\nrc = ResidueContributions(result, select(atoms, \"protein\"))\nrc_last_distance = [ c[end] for c in rc ]\n# or, equivalently\nrc_last_distance = last.(rc)\n# index and value of maximum contribution at each distance, for all residues\nfindmax.(rc60)\n\nArithmetic operations\n\nusing ComplexMixtures, PDBTools, Plots\n...\n# first simulation (for example, low temperature):\nresult1 = mddf(trajectory_file1, solute, solvent, options)\nrc1 = ResidueContributions(result1, select(atoms, \"protein\"))\n# second simulation (for example, high temperature):\nresult2 = mddf(trajectory_file2, solute, solvent, options)\nrc2 = ResidueContributions(result2, select(atoms, \"protein\"))\n# difference of the residue contributions between the two simulations:\nrc_diff = rc2 - rc1\ncontourf(rc_diff) # plots a contour map of the difference\n# multiply and divide by scalars\nrc3 = 3 * rc1\nrc4 = rc2 / 2\n\ncompat: Compat\nSlicing, indexing, and multiplication and division by scalars were introduces in v2.7.0. Saving and loading was introduced in v2.8.0. Iterators were introduced in v2.10.0.\n\n\n\n\n\n","category":"type"},{"location":"density_maps/#Plots.contourf-Tuple{ResidueContributions}","page":"Density maps","title":"Plots.contourf","text":"contourf(\n    rc::ResidueContributions; \n    step::Int=1, \n    oneletter=false, \n    xlabel=\"Residue\", \n    ylabel=\"r / Å\", \n    kargs...\n)\ncontour(rc::ResidueContributions; kargs...)\nheatmap(rc::ResidueContributions; kargs...)\n\nPlot the contribution of each residue to the solute-solvent pair distribution function as a 2D density map. This function requires loading the Plots package. The calling syntax for contour and heatmap is the same as for contourf.\n\nArguments\n\nrc::ResidueContributions: The residue contributions to the solute-solvent pair distribution function,  as computed by the ResidueContributions function.\n\nOptional arguments\n\nstep: The step of the residue ticks in the x-axis of the plot. Default is 1 or will be set to show at most 50 ticks labels.\noneletter::Bool: Use one-letter residue codes. Default is false. One-letter codes are only available for the 20 standard amino acids.\nxlabel and ylabel: Labels for the x and y axes. Default is \"Residue\" and \"r / Å\".\n\nThis function will set color limits and choose the scale automatically. These parameters can be set with the clims and color arguments of Plots.contourf. Other plot customizations can be  done by passing other keyword arguments to this function, which will be passed to Plots.contourf.\n\nExample\n\njulia> using ComplexMixtures, Plots, PDBTools\n\njulia> results = load(\"mddf.json\")\n\njulia> atoms = read_pdb(\"system.pdb\", \"protein\")\n\njulia> rc = ResidueContributions(results, atoms; oneletter=true)\n\njulia> plt = contourf(rc; step=5)\n\nThis will produce a plot with the contribution of each residue to the solute-solvent pair distribution function, as a contour plot, with the residues in the x-axis and the distance in the y-axis.\n\nTo customize the plot, use the Plot.contourf keyword parameters, for example:\n\njulia> plt = contourf(rc; step=5, size=(800,400), title=\"Title\", clims=(-0.1, 0.1))\n\ncompat: Compat\nThis function requires loading the Plots package.Support for all Plots.contourf parameters was introduced in ComplexMixtures v2.6.0, and support for contour and heatmap was introduced in ComplexMixtures v2.11.0. \n\n\n\n\n\n","category":"method"},{"location":"density_maps/#ComplexMixtures.load-Tuple{String, Type{ResidueContributions}}","page":"Density maps","title":"ComplexMixtures.load","text":"load(filename::String, ResidueContributions)\n\nFunction to load the residue contributions saved into a JSON file into the ResidueContributions data structure.\n\nExample\n\nusing ComplexMixtures\nrc = ResidueContributions(results, SoluteGroup(protein))\nsave(\"residue_contributions.json\", rc)\nrc = load(\"residue_contributions.json\", ResidueContributions)\n\n\n\n\n\n","category":"method"},{"location":"density_maps/#ComplexMixtures.save-Tuple{String, ResidueContributions}","page":"Density maps","title":"ComplexMixtures.save","text":"save(filename::String, rc::ResidueContributions)\n\nSave the ResidueContributions object to a JSON file.\n\nusing ComplexMixtures\nrc = ResidueContributions(results, SoluteGroup(protein))\nsave(\"residue_contributions.json\", rc)\nrc = load(\"residue_contributions.json\", ResidueContributions)\n\n\n\n\n\n","category":"method"},{"location":"density_maps/#ComplexMixtures.grid3D","page":"Density maps","title":"ComplexMixtures.grid3D","text":"grid3D(\n    result::Result, atoms, output_file::Union{Nothing,String} = nothing; \n    dmin=1.5, dmax=5.0, step=0.5, silent = false, type = :mddf,\n)\n\nThis function builds the grid of the 3D density function and fills an array of mutable structures of type Atom, containing the position of the atoms of  grid, the closest atom to that position, and distance. \n\nPositional arguments\n\nresult is a ComplexMixtures.Result object \natoms is a vector of PDBTools.Atoms with all the atoms of the system. \noutput_file is the name of the file where the grid will be written. If nothing, the grid is only returned as a matrix. \n\nKeyword (optional) arguments\n\ndmin and dmax define the range of distance where the density grid will be built, and step   defines how fine the grid must be. Be aware that fine grids involve usually a very large (hundreds   of thousands points).\nsilent is a boolean to suppress the progress bar.\ntype can be :mddf, :coordination_number, or :md_count, depending on the data available or desired from the results.\n\nThe output PDB has the following characteristics:\n\nThe positions of the atoms are grid points. \nThe identity of the atoms correspond to the identity of the protein atom contributing to the property at that point (the closest protein atom). \nThe temperature-factor column (beta) contains the relative contribution of that atom to the property at the corresponding distance. \nThe occupancy field contains the distance itself.\n\nExample\n\njulia> using ComplexMixtures, PDBTools\n\njulia> atoms = read_pdb(\"./system.pdb\");\n\njulia> R = ComplexMixtures.load(\"./results.json\");\n\njulia> grid = grid3D(R, atoms, \"grid.pdb\");\n\nExamples of how the grid can be visualized are provided in the user guide of ComplexMixtures. \n\n\n\n\n\n","category":"function"},{"location":"contributions/#contributions","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"One of the interesting features of Minimum-Distance distributions is that they can be naturally decomposed into the atomic or group contributions. Simply put, if a MDDF has a peak at a hydrogen-bonding distance, it is natural to decompose that peak into the contributions of each type of solute or solvent atom to that peak.     \n\ntip: Tip\nSee also the section on contributions per residue for proteins and other macromolecules: 2D density map per residue.\n\nTo obtain the atomic contributions of an atom or group of atoms to the MDDF, the coordination number, or the site count at each distance, the contributions function is provided. For example, in a system composed of a protein and water, we would have defined the solute and solvent using:\n\nusing PDBTools, ComplexMixtures\natoms = read_pdb(\"system.pdb\")\nprotein = select(atoms,\"protein\")\nwater = select(atoms,\"water\")\nsolute = AtomSelection(protein,nmols=1)\nsolvent = AtomSelection(water,natomspermol=3)\n\nThe MDDF calculation is executed with:\n\nresults = mddf(\"trajectory.dcd\", solute, solvent, Options(bulk_range=(8.0, 12.0)))","category":"section"},{"location":"contributions/#Atomic-contributions-in-the-result-data-structure","page":"Atomic and group contributions","title":"Atomic contributions in the result data structure","text":"The results data structure contains the decomposition of the MDDF into the contributions of every type of atom of the solute and the solvent. These contributions can be retrieved using the contributions function, with the SoluteGroup and SolventGroup selectors.","category":"section"},{"location":"contributions/#Example:-computing-the-oxygen-contributions-of-water","page":"Atomic and group contributions","title":"Example: computing the oxygen contributions of water","text":"Here we show the MDDF of water (solvent) relative to a solute. Water molecules have atom names OH2, H1, H2, one can retrieve the contributions of the oxygen atom with:\n\nOH2 = contributions(results, SolventGroup([\"OH2\"]))\n\nor with, if OH2 is the first atom in the molecule,\n\nOH2 = contributions(results, SolventGroup([1]))\n\nThe contributions of the hydrogen atoms can be obtained, similarly, with:\n\nH = contributions(results, SolventGroup([\"H1\", \"H2\"]))\n\nor with, if OH2 is the first atom in the molecule,\n\nH = contributions(results, SolventGroup([2, 3]))\n\nEach of these calls will return a vector of the contributions of these atoms to the total MDDF. \n\nFor example, here we plot the total MDDF and the Oxygen contributions: \n\nusing Plots\nplot(results.d, results.mddf, label=[\"Total MDDF\"], linewidth=2)\nplot!(results.d, contributions(results, SolventGroup([\"OH2\"])), label=[\"OH2\"], linewidth=2)\nplot!(xlabel=\"Distance / Å\", ylabel=\"MDDF\")\n\n<img src=\"../figures/oh2.png\" width=\"60%\">","category":"section"},{"location":"contributions/#Contributions-to-coordination-numbers-or-site-counts","page":"Atomic and group contributions","title":"Contributions to coordination numbers or site counts","text":"The keyword type defines the return type of the contribution:\n\ntype=:mddf : the contribution of the group to the MDDF is returned (default).\ntype=:coordination_number : the contribution of the group to the coordination number, that is, the   cumulative sum of counts at each distance, is returned.\ntype=:md_count : the contribution of the group to the site count at each distance is returned. \n\nExample of the usage of the type option:\n\nca_contributions = contributions(results, SoluteGroup([\"CA\"]); type=:coordination_number)","category":"section"},{"location":"contributions/#Using-PDBTools","page":"Atomic and group contributions","title":"Using PDBTools","text":"If the solute is a protein, or other complex molecule, selections defined with PDBTools can be used. For example, this will retrieve the contribution of the acidic residues of a protein to total MDDF:\n\nusing PDBTools\natoms = read_pdb(\"system.pdb\")\nacidic_residues = select(atoms, \"acidic\")\nacidic_contributions = contributions(results, SoluteGroup(acidic_residues))\n\nIt is expected that for a protein most of the atoms do not contribute to the MDDF, and that all values are zero at very short distances, smaller than the radii of the atoms.\n\nMore interesting and general is to select atoms of a complex molecule, like a protein, using residue names, types, etc. Here we illustrate how this is done by providing selection strings to contributions to obtain the contributions to the MDDF of different types of residues of a protein to the total MDDF. \n\nFor example, if we want to split the contributions of the charged and neutral residues to the total MDDF distribution, we could use to following code. Here, solute refers to the protein.\n\ncharged_residues = PDBTools.select(atoms,\"charged\")\ncharged_contributions = contributions(results, SoluteGroup(charged_residues))\n\nneutral_residues = PDBTools.select(atoms,\"neutral\")\nneutral_contributions = contributions(atoms, SoluteGroup(neutral_residues))\n\nThe charged_contributions and neutral_contributions outputs are vectors containing the contributions of these residues to the total MDDF. The corresponding plot is:   \n\nplot(results.d,results.mddf,label=\"Total MDDF\",linewidth=2)\nplot!(results.d,charged_contributions,label=\"Charged residues\",linewidth=2)\nplot!(results.d,neutral_contributions,label=\"Neutral residues\",linewidth=2)\nplot!(xlabel=\"Distance / Å\",ylabel=\"MDDF\")\n\nResulting in:\n\n<img src=\"../figures/charged_and_neutral.png\" width=\"60%\">\n\nNote here how charged residues contribute strongly to the peak at hydrogen-bonding distances, but much less in general. Of course all selection options could be used, to obtain the contributions of specific types of residues, atoms, the backbone, the side-chains, etc. ","category":"section"},{"location":"contributions/#ComplexMixtures.contributions","page":"Atomic and group contributions","title":"ComplexMixtures.contributions","text":"contributions(R::Result, group::Union{SoluteGroup,SolventGroup}; type = :mddf)\n\nReturns the contributions of the atoms of the solute or solvent to the MDDF, coordination number, or MD count.\n\nArguments\n\nR::Result: The result of a calculation.\ngroup::Union{SoluteGroup,SolventGroup}: The group of atoms to consider.\ntype::Symbol: The type of contributions to return. Can be :mddf (default), :coordination_number, or :md_count.\n\nExamples\n\njulia> using ComplexMixtures, PDBTools\n\njulia> dir = ComplexMixtures.data_dir*\"/Gromacs\";\n\njulia> atoms = read_pdb(dir*\"/system.pdb\");\n\njulia> protein = select(atoms, \"protein\");\n\njulia> emim = select(atoms, \"resname EMI\"); \n\njulia> solute = AtomSelection(protein, nmols = 1)\nAtomSelection \n    1231 atoms belonging to 1 molecule(s).\n    Atoms per molecule: 1231\n    Number of groups: 1231\n\njulia> solvent = AtomSelection(emim, natomspermol = 20)\nAtomSelection \n    5080 atoms belonging to 254 molecule(s).\n    Atoms per molecule: 20\n    Number of groups: 20\n\njulia> results = load(dir*\"/protein_EMI.json\"); # load pre-calculated results\n\njulia> ca_cb = contributions(results, SoluteGroup([\"CA\", \"CB\"])); # contribution of CA and CB atoms to the MDDF\n\njulia> ca_cb = contributions(results, SoluteGroup([\"CA\", \"CB\"]); type=:coordination_number); # contribution of CA and CB atoms to the coordination number\n\n\n\n\n\n","category":"function"},{"location":"contributions/#ComplexMixtures.SolventGroup","page":"Atomic and group contributions","title":"ComplexMixtures.SolventGroup","text":"SoluteGroup and SolventGroup data structures.\n\nThese structures are used to select groups of atoms to extract their contributions  from the MDDF results. \n\nMost typically, the groups are defined from a selection of atoms with the PDBTools package, or by providing directly the indices of the atoms in the structure. \n\nAlternatively, if the groups were predefined, the groups can be selected by group index or group name. \n\nThe possible constructors are:\n\nSoluteGroup(atoms::Vector{<:PDBTools.Atom})\nSoluteGroup(atom_indices::AbstractVector{<:Integer})\nSoluteGroup(atom_names::AbstractVector{<:AbstractString})\nSoluteGroup(group_name::AbstractString)\nSoluteGroup(residue::PDBTools.Residue)\n\nabove, each constructor can be replaced by SolventGroup. The resulting data structures  are used as input parameters for the contributions function:\n\ncontributions(results::Result, group::Union{SoluteGroup, SolventGroup}; type=:mddf)\n\nSee the contributions help entry for additional information.\n\nExamples\n\nDefining solute groups with different input types:\n\njulia> using ComplexMixtures, PDBTools\n\njulia> atoms = PDBTools.read_pdb(ComplexMixtures.pdb_file_example, \"protein\"); \n\njulia> SoluteGroup(select(atoms, \"protein and resname ASP\")) # vector of PDBTools.Atom(s)\nSoluteGroup defined by:\n    atom_indices: [ 24, 25, ..., 1056, 1057 ] - 72 atoms\n\njulia> SoluteGroup(1:100) # atom indices (range or vector)\nSoluteGroup defined by:\n    atom_indices: [ 1, 2, ..., 99, 100 ] - 100 atoms\n\njulia> SoluteGroup([\"N\", \"CA\", \"C\", \"O\"]) # vector of atom names\nSoluteGroup defined by:\n    atom_names: [ N, CA, C, O ] - 4 atom names.\n \njulia> SoluteGroup(\"acidic residues\") # predefined group name\nSoluteGroup defined by:\n    group_name: \"acidic residues\"\n\njulia> SoluteGroup(1) # predefined group index\nSoluteGroup defined by:\n    group_index: 1\n\njulia> SoluteGroup(collect(eachresidue(atoms))[2]) # PDBTools.Residue(s)\nSoluteGroup defined by:\n    atom_indices: [ 13, 14, ..., 22, 23 ] - 11 atoms\n\n\n\n\n\n\n","category":"type"},{"location":"contributions/#ComplexMixtures.SoluteGroup","page":"Atomic and group contributions","title":"ComplexMixtures.SoluteGroup","text":"SoluteGroup and SolventGroup data structures.\n\nThese structures are used to select groups of atoms to extract their contributions  from the MDDF results. \n\nMost typically, the groups are defined from a selection of atoms with the PDBTools package, or by providing directly the indices of the atoms in the structure. \n\nAlternatively, if the groups were predefined, the groups can be selected by group index or group name. \n\nThe possible constructors are:\n\nSoluteGroup(atoms::Vector{<:PDBTools.Atom})\nSoluteGroup(atom_indices::AbstractVector{<:Integer})\nSoluteGroup(atom_names::AbstractVector{<:AbstractString})\nSoluteGroup(group_name::AbstractString)\nSoluteGroup(residue::PDBTools.Residue)\n\nabove, each constructor can be replaced by SolventGroup. The resulting data structures  are used as input parameters for the contributions function:\n\ncontributions(results::Result, group::Union{SoluteGroup, SolventGroup}; type=:mddf)\n\nSee the contributions help entry for additional information.\n\nExamples\n\nDefining solute groups with different input types:\n\njulia> using ComplexMixtures, PDBTools\n\njulia> atoms = PDBTools.read_pdb(ComplexMixtures.pdb_file_example, \"protein\"); \n\njulia> SoluteGroup(select(atoms, \"protein and resname ASP\")) # vector of PDBTools.Atom(s)\nSoluteGroup defined by:\n    atom_indices: [ 24, 25, ..., 1056, 1057 ] - 72 atoms\n\njulia> SoluteGroup(1:100) # atom indices (range or vector)\nSoluteGroup defined by:\n    atom_indices: [ 1, 2, ..., 99, 100 ] - 100 atoms\n\njulia> SoluteGroup([\"N\", \"CA\", \"C\", \"O\"]) # vector of atom names\nSoluteGroup defined by:\n    atom_names: [ N, CA, C, O ] - 4 atom names.\n \njulia> SoluteGroup(\"acidic residues\") # predefined group name\nSoluteGroup defined by:\n    group_name: \"acidic residues\"\n\njulia> SoluteGroup(1) # predefined group index\nSoluteGroup defined by:\n    group_index: 1\n\njulia> SoluteGroup(collect(eachresidue(atoms))[2]) # PDBTools.Residue(s)\nSoluteGroup defined by:\n    atom_indices: [ 13, 14, ..., 22, 23 ] - 11 atoms\n\n\n\n\n\n\n","category":"type"},{"location":"example1/#Protein-in-water/glycerol","page":"Protein in water/glycerol","title":"Protein in water/glycerol","text":"The following examples consider a system composed a protein solvated by a mixture of water and glycerol, built with Packmol. The simulations were performed with NAMD with periodic boundary conditions and a NPT ensemble at room temperature and pressure. Molecular pictures were produced with VMD and plots were produced with Julia's Plots library.\n\n<center>\n<img width=50% src=\"../figures/prot_glyc_system.png\">\n</center>\n\nImage of the system of the example: a protein solvated by a mixture of glycreol (green) and water, at a concentration of 50%vv. ","category":"section"},{"location":"example1/#Index","page":"Protein in water/glycerol","title":"Index","text":"Data, packages, and execution\nMDDF, KB integrals, and group contributions\n2D density map\n3D density map","category":"section"},{"location":"example1/#data-example1","page":"Protein in water/glycerol","title":"Data, packages, and execution","text":"The files required to run this example are available at [this link], and are: \n\nsystem.pdb: The PDB file of the complete system.\nglyc50_traj.dcd: Trajectory file. This is a 1GB file, necessary for running from scratch the calculations.\n\nTo run the scripts, we suggest the following procedure:\n\nCreate a directory, for example example1.\nUnzip and copy the required data files above to this directory.\nLaunch julia in that directory, activate the directory environment, and install the required packages.  This is done by launching Julia and executing:\nimport Pkg \nPkg.activate(\".\")\nPkg.add([\"ComplexMixtures\", \"PDBTools\", \"Plots\", \"LaTeXStrings\", \"EasyFit\"])\nexit()\nCopy the code of each script in to a file, and execute with:\njulia -t auto script.jl\nAlternatively (and perhaps preferably), copy line by line the content of the script into the Julia REPL, to follow each step of the calculation. For a more advanced Julia usage, we suggest the VSCode IDE with the  Julia Language Support extension. ","category":"section"},{"location":"example1/#mddf-example1","page":"Protein in water/glycerol","title":"MDDF, KB integrals, and group contributions","text":"Here we compute the minimum-distance distribution function, the Kirkwood-Buff integral, and the atomic contributions of the solvent to the density. This example illustrates the regular usage of ComplexMixtures, to compute the minimum distance distribution function, KB-integrals and group contributions. \n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example1/script1.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>","category":"section"},{"location":"example1/#Output","page":"Protein in water/glycerol","title":"Output","text":"The code above will produce the following plots, which contain the minimum-distance distribution of  glycerol relative to the protein, and the corresponding KB integral:\n\n<center>\n<img width=100% src=\"../assets/scripts/example1/mddf.png\">\n</center>\n\nand the same distribution function, decomposed into the contributions of the hydroxyl and aliphatic groups of glycerol:\n\n<center>\n<img width=70% src=\"../assets/scripts/example1/mddf_atom_contrib.png\">\n</center>\n\nnote: Note\nTo change the options of the calculation, set the Options structure accordingly and pass it as a parameter to mddf. For example:options = Options(bulk_range=(10.0, 15.0), stride=5)\nmddf(trajectory_file, solute, solvent, options)The complete set of options available is described here.","category":"section"},{"location":"example1/#2D-map-example1","page":"Protein in water/glycerol","title":"2D density map","text":"In this followup from the example above, we compute group contributions of the solute (the protein) to the MDDFs, split into the contributions each protein residue. This allows the observation of the penetration of the solvent on the structure, and the strength of the interaction of the solvent, or cossolvent, with each type of residue in the structure. The ResidueContributions and Plots.contourf auxiliary functions, documented here, are used:  \n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example1/script2.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>","category":"section"},{"location":"example1/#Output-2","page":"Protein in water/glycerol","title":"Output","text":"The code above will produce the following plot, which contains, for each residue, the contributions of each residue to the distribution function of glycerol, within 1.5 to 3.5 mathrmAA of the surface of the protein.\n\n<center>\n<img width=70% src=\"../assets/scripts/example1/density2D.png\">\n</center>","category":"section"},{"location":"example1/#3D-map-example1","page":"Protein in water/glycerol","title":"3D density map","text":"In this example we compute three-dimensional representations of the density map of Glycerol in the vicinity of a set of residues of a protein, from the minimum-distance distribution function.  For further information about the grid3D function, go to the 3D grid map section of the manual.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example1/script3.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\nHere, the MDDF is decomposed at each distance according to the contributions of each solute (the protein) residue. The grid is created such that, at each point in space around the protein, it is possible to identify: \n\nWhich atom is the closest atom of the solute to that point.\nWhich is the contribution of that atom (or residue) to the distribution function.\n\nTherefore, by filtering the 3D density map at each distance one can visualize over the solute structure which are the regions that mostly interact with the solvent of choice at each distance. Typical images of such a density are:\n\n<center>\n<img width=100% src=\"../figures/density3D_final.png\">\n</center>\n\nIn the figure on the left, the points in space around the protein are selected with the following properties: distance from the protein smaller than 2.0Å and relative contribution to the MDDF at the corresponding distance of at least 10% of the maximum contribution. Thus, we are selecting the regions of the protein corresponding to the most stable hydrogen-bonding interactions. The color of the points is the contribution to the MDDF, from blue to red. Thus, the most reddish-points corresponds to the regions where the most stable hydrogen bonds were formed. We have marked two regions here, on opposite sides of the protein, with arrows.\n\nClicking on those points we obtain which are the atoms of the protein contributing to the MDDF at that region. In particular, the arrow on the right points to the strongest red region, which corresponds to an Aspartic acid. These residues are shown explicitly under the density (represented as a transparent surface) on the figure in the center.\n\nThe figure on the right displays, overlapped with the hydrogen-bonding residues, the most important contributions to the second peak of the distribution, corresponding to distances from the protein between 2.0 and 3.5Å. Notably, the regions involved are different from the ones forming hydrogen bonds, indicating that non-specific interactions with the protein (and not a second solvation shell) are responsible for the second peak. ","category":"section"},{"location":"example1/#How-to-run-this-example:","page":"Protein in water/glycerol","title":"How to run this example:","text":"Assuming that the input files are available in the script directory, just run the script with:\n\njulia density3D.jl\n\nAlternatively, open Julia and copy/paste or the commands in density3D.jl or use include(\"./density3D.jl\"). These options will allow you to remain on the Julia section with access to the grid data structure that was generated and corresponds to the output grid.pdb file. \n\nThis will create the grid.pdb file. Here we provide a previously setup VMD session that contains the data with the visualization choices used to generate the figure above. Load it with:\n\nvmd -e grid.vmd\n\nA short tutorial video showing how to open the input and output PDB files in VMD and produce images of the density is available here: \n\n<center>\n<iframe width=\"560\" style=\"height:315px\" src=\"https://www.youtube.com/embed/V4Py44IKDh8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</center>","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"note: Note\nThis is a package written in Julia. We invite you to experiment with the language, but if you want to just call this package  from Python, read the From Python section of the manual. Understanding all the features of the package  requires reading the manual as whole. The syntaxes of using this package from Julia or Python are almost identical, and the motivation for using Python should be mostly the familiarity with further analysis tools, as the plotting packages. ","category":"section"},{"location":"installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"First you need to install the Julia language, version 1.9 or greater is required.  Using the juliaup tool is a highly recommended way of installing and keeping Julia up to date.\n\nAlternatively, you can install Julia by downloading the binaries directly from the Julia webpage.\n\nnote: Note\nNew to Julia? Julia is a modern high-level yet performant programming language. Some tips and a nice workflow for using it effectively can be found here. For this specific package, following a the step-by-step examples provided here after installing Julia should be enough. ","category":"section"},{"location":"installation/#Install-the-packages","page":"Installation","title":"Install the packages","text":"Within Julia, to install the packages required for running the examples here you need to do:\n\njulia> import Pkg\n\njulia> Pkg.add([\"ComplexMixtures\", \"PDBTools\", \"Plots\", \"EasyFit\", \"LaTeXStrings\"])\n\nHere, PDBTools.jl is an auxiliary package to read PDB files and select atoms within them. The Plots, EasyFit and LaTeXStrings packages will help producing nice looking plots. \n\nPlease read the recommended workflow below, for further information and to be sure to have a smoother experience.","category":"section"},{"location":"installation/#Recommended-workflow-for-reproducibility","page":"Installation","title":"Recommended workflow for reproducibility","text":"","category":"section"},{"location":"installation/#Create-an-environment","page":"Installation","title":"Create an environment","text":"Once Julia is installed, we recommend to create an environment that will contain all the packages you may use for your analyses, including ComplexMixtures, in such a way that your results can always be reproduced and you don't get any version incompatibility.\n\nWe illustrate this by creating the \"MyNewPaper\" environment, which will be hosted in a simple directory,\n\nmkdir /home/user/Documents/MyNewPaper\n\nThen, start Julia and activate the environment that will be hosted there:\n\njulia> import Pkg; Pkg.activate(\"/home/user/Documents/MyNewPaper\")\n  Activating new project at `~/Documents/MyNewPaper`\n\nand add to this environment the packages that your analyses will require:\n\njulia> import Pkg; Pkg.add([\"ComplexMixtures\",\"PDBTools\",\"Plots\", \"EasyFit\", \"LaTeXStrings\"])\n\nThat's it. Close Julia. Note that this created the files Manifest.toml and Project.toml in the MyNewPaper directory, which contain the information of packages and exact package versions you are using now on in this environment. Saving these files may be relevant for the future exact reproduction of your analyses. ","category":"section"},{"location":"installation/#Run-your-analysis-scripts-in-that-environment","page":"Installation","title":"Run your analysis scripts in that environment","text":"Now, your analysis scripts, described in the next section in details, will look like: \n\nimport Pkg; Pkg.activate(\"/home/user/Documents/MyNewPaper\")\n\nusing ComplexMixtures\nusing PDBTools\nusing Plots\nusing EasyFit\nusing LaTeXStrings\n\n# etc ... \n\nAnd the script can be run with julia -t auto script.jl (where -t auto allows for multi-threading),  or included in julia with julia> include(\"./script.jl\"), as described in the next section.\n\ntip: Tip\nBy loading the package with using ComplexMixturesthe most common functions of the package become readily available by their direct name,  for example mddf(...).If you don't want to bring the functions into the scope of your script, useimport ComplexMixturesThen, the functions of the package are called, for example, using ComplexMixtures.mddf(...). To avoid having to write ComplexMixtures all the time, define an acronym. For example:import ComplexMixtures as CM\nCM.mddf(...)","category":"section"},{"location":"mddf/#Computing-the-MDDF","page":"Computing the MDDF","title":"Computing the MDDF","text":"","category":"section"},{"location":"mddf/#Minimum-Distance-Distribution-Function","page":"Computing the MDDF","title":"Minimum-Distance Distribution Function","text":"The main function of the ComplexMixtures package actually computes the MDDF between the solute and the solvent chosen. \n\nThe mddf functions is run with, for example:\n\nresults = mddf(trajectory_file, solute, solvent, Options(bulk_range=(10.0, 15.0)))  \n\nThe MDDF along with other results, like the corresponding KB integrals, are returned in the results data structure, which is described in the next section.\n\nIt is possible to tune several options of the calculation, by setting the Options data structure with user-defined values in advance. The most common parameters to be set by the user are bulk_range and stride. \n\nstride defines if some frames will be skip during the calculation (for speedup). For example, if stride=5, only one in five frames will be considered. Adjust stride with:  \n\noptions = Options(stride=5, bulk_range=(10.0, 15.0))\nresults = mddf(trajectory_file, solute, solvent, options)\n\nnote: Note\nbulk_range defines the subset of the system, as defined according to a range of distances from the solute, that are to be considered as the bulk solution. Within this range of distances, the user  believes that the reference solute molecule does not significantly affect anymore the structure of the solvent. By default, all molecules above 10 Angstroms from the solute are considered bulk molecules (corresponding to Options(dbulk=10.0)), but it is highly recommended to use a manual definition of bulk_range.The definition of a range of distances within the system to compute the bulk density is adequate because this system subset is then an open system with a solvent molecule reservoir. The adequate choice of bulk_range can be inspected by the proper convergence of the distribution functions (which must converge to 1.0) and a proper convergence of the KB integrals.The bulk_range option was introduced in version 2.1.0.\n\nSee the Options section for further details and other options to set.","category":"section"},{"location":"mddf/#Coordination-numbers-only","page":"Computing the MDDF","title":"Coordination numbers only","text":"The coordination number is the unnormalized count of how many molecules of the solvent are within a given distance to the solute. Coordination numbers can be computed  for systems where the normalization of the distribution functions is not possible (or needed) because of an ill definition of an ideal-gas state. For example,  in highly heterogeneous systems, on in systems with only a few molecules of the  \"solvent\", the density of the bulk solution might not be properly defined.   \n\nIn these cases, nevertheless, coordination numbers can be computed and still  provide valuable information about the molecular structure of the system. Coordination number can be computed also from the results obtained from a mddf run, as explained in  the corresponding section of the Tools menu.\n\nThe coordination_number function, called with the same arguments as the mddf function, can be used to compute coordination numbers without the normalization required for the MDDF, providing (possibly much) faster computations when the  normalization is not possible or required:\n\nnote: Note\nThe mddf, kb, and random count parameters will be filled with zeros when using  this options, and are meaningless. ","category":"section"},{"location":"mddf/#ComplexMixtures.mddf","page":"Computing the MDDF","title":"ComplexMixtures.mddf","text":"mddf(\n    trajectory_file::String, \n    solute::AtomSelection,\n    solvent::AtomSelection, # optional: if omitted, an auto-correlation will be computed\n    options::Options=Options(); # optional: if omitted, default options will be used\n    # optional keywords:\n    trajectory_format=\"\", \n    frame_weights = Float64[], \n    coordination_number_only = false, \n    low_memory = false, \n    chemfiles = false,\n)\n\nComputes the minimum-distance distribution function, atomic contributions, and  KB integrals, given the trajectory file name, and the definition of the solute and solvent groups of atoms as AtomSelection data structures. If the solvent parameter is omitted, a self-correlation will be computed.\n\nThis is the main function of the ComplexMixtures package. \n\nThe options parameter is optional. If not set, the default Options() structure will be used.\n\nOptional execution keywords\n\ntrajectory_format is a string that defines the format of the trajectory file. If not provided, the format  will be guessed from the file extension, and the Chemfiles library will be used to read the trajectory. \nframe_weights is an array of weights for each frame of the trajectory. If this is provided, the MDDF will be computed as a weighted average of the MDDFs of each frame. This can be used to study the solvation dependency in perturbed  ensembles.\ncoordination_number_only is a boolean that, if set to true, will compute only the site-counts and coordination numbers of the solvent molecules around the solute, and not the MDDF, RDF, or KB integrals.  This is useful when the normalization of the distribution is not possible or needed, for instance when the bulk solution is not properly defined. The computation is much faster in this case. The call to mddf with this option is equivalent to direct the call to coordination_number.\nlow_memory can be set to true to reduce the memory requirements of the computation. This will parallelize the computation of the minimum distances at a lower level, reducing the memory requirements at the expense of some performance.\nchemfiles is a boolean that, if set to true, will use try to use the Chemfiles library to read the trajectory file.  independently of the file extension. By default, PDB and DCD trajectories are read by specific readers.\n\ncompat: Compat\nThe current call signature was introduced in version 2.9.0. The previous call signature with the  previous construction of the Trajectory object, is still available, but it is no longer recommended  because it more prone to user-level solute and solvent configuration errors. \n\nExamples\n\njulia> using ComplexMixtures, PDBTools\n\njulia> using ComplexMixtures: data_dir\n\njulia> atoms = read_pdb(joinpath(data_dir,\"NAMD/structure.pdb\"));\n\njulia> solute = AtomSelection(select(atoms, \"protein\"), nmols=1);\n\njulia> solvent = AtomSelection(select(atoms, \"resname TMAO\"), natomspermol=14);\n\njulia> options = Options(lastframe=10, bulk_range=(10.0, 15.0));\n\njulia> trajectory_file = joinpath(data_dir,\"NAMD/trajectory.dcd\");\n\njulia> results = mddf(trajectory_file, solute, solvent, options);\n\n\n\n\n\n","category":"function"},{"location":"mddf/#MolSimToolkitShared.coordination_number-Tuple{String, AtomSelection, AtomSelection, Options}","page":"Computing the MDDF","title":"MolSimToolkitShared.coordination_number","text":"coordination_number(\n    trajectory_file::String, \n    solute::AtomSelection,\n    solvent::AtomSelection, # optional: if omitted, an auto-correlation will be computed\n    options::Options=Options(); # optional: if omitted, default options will be used\n    # optional keywords:\n    trajectory_format=\"\", \n    frame_weights = Float64[], \n    low_memory = false, \n)\n\nComputes the minimum-distance coordination number and atomic contributions, given the trajectory file name, and the definition of the solute and solvent groups of atoms as AtomSelection data structures. If the solvent parameter is omitted, a self-coordination number will be computed.\n\nThe output is a Result structure, which contains the data as the result of a call to mddf, except that all counters which require normalization of the distribution will be zero. In summary, this result data structure can be used to compute the coordination numbers, but not the MDDF, RDF, or KB integrals.\n\nThe options parameter is optional. If not set, the default Options() structure will be used.\n\nOptional execution keywords\n\ntrajectory_format is a string that defines the format of the trajectory file. If not provided, the format  will be guessed from the file extension, and the Chemfiles library will be used to read the trajectory. \nframe_weights is an array of weights for each frame of the trajectory. If this is provided, the MDDF will be computed as a weighted average of the MDDFs of each frame. This can be used to study the solvation dependency in perturbed  ensembles.\nlow_memory can be set to true to reduce the memory requirements of the computation. This will parallelize the computation of the minimum distances at a lower level, reducing the memory requirements at the expense of some performance.\nchemfiles is a boolean that, if set to true, will use try to use the Chemfiles library to read the trajectory file.  independently of the file extension. By default, PDB and DCD trajectories are read by specific readers.\n\ncompat: Compat\nThe current call signature was introduced in version 2.9.0. The previous call signature with the  previous construction of the Trajectory object, is still available, but it is no longer recommended  because it more prone to user-level solute and solvent configuration errors. \n\nExamples\n\njulia> using ComplexMixtures, PDBTools\n\njulia> using ComplexMixtures: data_dir\n\njulia> atoms = read_pdb(joinpath(data_dir,\"NAMD/structure.pdb\"));\n\njulia> solute = AtomSelection(select(atoms, \"protein\"), nmols=1);\n\njulia> solvent = AtomSelection(select(atoms, \"resname TMAO\"), natomspermol=14);\n\njulia> options = Options(lastframe=10, bulk_range=(10.0, 15.0));\n\njulia> trajectory_file = joinpath(data_dir,\"NAMD/trajectory.dcd\");\n\njulia> results = coordination_number(trajectory_file, solute, solvent, options);\n\n\n\n\n\n","category":"method"},{"location":"parallel/#Parallel-execution","page":"Parallel execution","title":"Parallel execution","text":"It is highly recommended to run MDDF calculations in parallel, using multiple processors of a  single computer. To run the computation in parallel, initialize julia with the -t N option, where N is the number of processes to be used. For example, to use 8 parallel processes, use:\n\njulia -t 8 example.jl\n\nThe computation will use a number of parallel processes equal to N. Use -t auto to automatically pick the number of threads available in your computer. ","category":"section"},{"location":"parallel/#Optimal-number-of-threads","page":"Parallel execution","title":"Optimal number of threads","text":"The number of threads used for computation of the MDDF is the number of threads available to Julia.  Many computers allow hyperthreading, and not necessarily this this beneficial for the execution of this package. The optimal number of threads may vary. Some newer CPUs have \"energy saving\" cores, which are also relatively slow.\n\nIndependently of the number of threads initialized with the -t command-line parameter, the number of processes launched by ComplexMixtures in any  given computation can be adjusted by the Options(nthreads=N) option. This won't provide any speedup if the optional number of threads is greater than the number of threads available to Julia at runtime.","category":"section"},{"location":"parallel/#Memory-issues","page":"Parallel execution","title":"Memory issues","text":"If the calculations get Killed by no apparent reason, that is probably because you are running out of memory because of the many parallel computations running. \n\nThe main reason for memory exhaustion is the annotation of the contributions of each atom of the solute molecules to the total counts. By default, in a parallel run, one copy of such data structures is saved for each thread. This might be an issue if the solute is molecular structure with  many hundreds of thousand atoms, and if the number of CPUs available is  very high, but memory is not as abundant.\n\nThere are different ways to deal with this issue:\n\nUse predefined groups, to reduce the size of the group array contributions.\nUse the low_memory=true option the call to mddf (for example with mddf(traj, options; low_memory=true). \nReduce the number of threads used (with Options(nthreads=N)).\nIncrease the frequency of garbage collection calls:\noptions = Options(GC=true, GC_threshold=0.5)\nR = mddf(trajectory_file, solute, solvent, options)\nThe GC_threshold=0.5 indicates that if the free memory is smaller than 50% of the total memory of the machine, a garbage-collection run will occur. The   default parameters are GC=true and GC_threshold=0.3.  ","category":"section"},{"location":"multiple/#Working-with-multiple-trajectories","page":"Multiple trajectories","title":"Working with multiple trajectories","text":"Very commonly, one has multiple trajectories of the same system, and we want to obtain the average results of all trajectories. We provide a simple scheme to average the results of multiple MDDF calculations:","category":"section"},{"location":"multiple/#Create-a-vector-of-result-data-structures,-without-initialization","page":"Multiple trajectories","title":"Create a vector of result data structures, without initialization","text":"Let us assume that we have three Gromacs trajectories, with file names traj1.xtc, traj2.xtc, traj3.xtc. First let us create a list with these file names:\n\ntrajectory_files = [ \"traj1.xtc\" , \"traj2.xtc\" , \"traj3.xtc\" ]\n\nAnd define an empty vector of Result structures:\n\nresults = Result[]","category":"section"},{"location":"multiple/#Run-the-calculations-in-a-loop","page":"Multiple trajectories","title":"Run the calculations in a loop","text":"The calculation on the multiple trajectories is then performed in a simple loop, such as\n\natoms = PDBTools.read_pdb(\"./system.pdb\")\nsolute = AtomSelection(atoms,\"protein\",nmols=1)\nsolvent = AtomSelection(atoms,\"resname TMAO\",natomspermol=14)\noptions = Options(bulk_range=(8.0, 12.0))\nfor file in trajectory_files\n    # compute the MDDF data and push the result to the results array\n    push!(results, mddf(trajectory_file, solute, solvent, options))\nend","category":"section"},{"location":"multiple/#Merge-the-results-of-several-trajectories,-with-proper-weights","page":"Multiple trajectories","title":"Merge the results of several trajectories, with proper weights","text":"Of course, the resulting results vector will contain at each position the results of each calculation. To merge these results in a single result data structure, use:\n\nR = merge(results)\n\nThe R structure generated contains the averaged results of all calculations, with weights proportional to the number of frames of each trajectory. That is, if the first trajectory had 2000 frames, and the second and third trajectories have 1000 frames each, the first trajectory will have a weight of 0.5 on the final results. The merge function can be used to merge previously merged results with new results as well.\n\ntip: Tip\nThe names of the files and and weights are stored in the R.files and R.weights vectors of the results structure:julia> R.files\n3-element Array{String,1}:\n \"./traj1.xtc\"\n \"./traj2.xtc\"\n \"./traj3.xtc\"\n\njulia> R.weights\n2-element Array{Float64,1}:\n 0.5\n 0.25\n 0.25\nIt is not a bad idea to check if that is what you were expecting.","category":"section"},{"location":"multiple/#Base.merge","page":"Multiple trajectories","title":"Base.merge","text":"merge(r::Vector{Result})\n\nThis function merges the results of MDDF calculations obtained by running the same analysis on multiple trajectories, or multiple parts of the same trajectory. It returns a Result structure of the same type, with all the functions and counters representing averages of the set provided weighted by the number of frames read in each Result set.\n\n\n\n\n\n","category":"function"},{"location":"save/#save","page":"Save and load","title":"Save and load results","text":"Three functions serve the purpose of saving and loading the results obtained with ComplexMixtures:","category":"section"},{"location":"save/#Save-data-to-recover-it-later","page":"Save and load","title":"Save data to recover it later","text":"save(\"results.json\", results)\n\nwhere results is the output data structure of the mddf() calculation, and results.json is the output file to be created. The file is written in JSON format, thus is not naturally human-readable.","category":"section"},{"location":"save/#Load-saved-data","page":"Save and load","title":"Load saved data","text":"results = load(\"results.json\")\n\nThe load function reads the output of the save function above, and restores the results data structure.","category":"section"},{"location":"save/#Write-data-in-a-human-readable-format","page":"Save and load","title":"Write data in a human-readable format","text":"If you Want the results to be written as simple ASCII tables such that you can read them with another analysis program, plotting graphic, or just want to inspect the data visually, use:\n\nwrite(\"results.dat\", results)\n\nThree files will be created by this function:\n\nresults.dat: Contains the main results, as the MDDF and KB-integral data.\n\nresults-ATOM_CONTRIB_SOLVENT.dat: contains the contribution of each atom type of the solvent to the MDDF.\n\nresults-ATOM_CONTRIB_SOLUTE.dat: contains the contribution of each atom type of the solute to the MDDF.","category":"section"},{"location":"save/#ComplexMixtures.save-Tuple{String, Result}","page":"Save and load","title":"ComplexMixtures.save","text":"save(filename::String, R::Result)\n\nFunction to write the result data structure to a json file.\n\n\n\n\n\n","category":"method"},{"location":"save/#ComplexMixtures.load-Tuple{String, Type{Result}}","page":"Save and load","title":"ComplexMixtures.load","text":"load(filename::String, [::Type{Result}=Result])\n\nFunction to load the json saved results file into, by default, the Result data structure. The second parameter is optional for loading Result objects.\n\nExample\n\nusing ComplexMixtures: load\nR = load(\"results.json\")\n#or\nR = load(\"results.json\", Result)\n\n\n\n\n\n","category":"method"},{"location":"save/#Base.write-Tuple{String, Result}","page":"Save and load","title":"Base.write","text":"write(\n    R::Result, filename::String;\n    solute_group_names::AbstractVector{<:AbstractString} = R.solute.group_names,\n    solvent_group_names::AbstractVector{<:AbstractString} = R.solvent.group_names,\n)\n\nFunction to write the final results to output files as simple tables that are human-readable and easy to analyze with other software\n\nIf the solute and solvent group names are defined in R, the solute_group_names and solvent_group_names arguments are not necessary. If they are not defined, the user can pass the names of the groups as strings in the solute_group_names and solvent_group_names arguments.\n\n\n\n\n\n","category":"method"},{"location":"quickguide/#Quick-Guide","page":"Quick Guide","title":"Quick Guide","text":"First, follow the installation instructions.  Below is a complete working example, followed by detailed descriptions  of each command.","category":"section"},{"location":"quickguide/#Basic-example","page":"Quick Guide","title":"Basic example","text":"Here we show the input file required for the study of the solvation of a protein by the TMAO solvent, which is a molecule with 14 atoms. The protein is assumed to be at infinite dilution in the simulation. The trajectory of the simulation is in DCD format in this example, which is the default output of NAMD and CHARMM simulation packages.","category":"section"},{"location":"quickguide/#Input-files","page":"Quick Guide","title":"Input files","text":"The files necessary to run this would be:\n\nsystem.pdb: a PDB file of the complete simulated system.\ntrajectory.dcd: the simulation trajectory, here exemplified in the DCD format.\nscript.jl: the Julia script, described below.\n\nThese files are not provided for this example. For complete running examples, please check our examples section.","category":"section"},{"location":"quickguide/#The-Julia-script","page":"Quick Guide","title":"The Julia script","text":"using Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/basic/script.jl\", String))\n\\`\\`\\`\n\"\"\")\n\nGiven that this code is saved into a file named script.jl, it can be run within the Julia REPL with:\n\njulia> include(\"script.jl\")\n\nor directly with:\n\njulia -t auto script.jl\n\nwhere -t auto will launch julia with multi-threading. It is highly recommended to use multi-threading!\n\nnote: Note\nSome newer CPUs have \"fast\" and \"slow\" cores, designed for performance or energy savings. Thus using all cores, with -t auto, may not be the best strategy for optimal performance. Experimenting with different number of cores using -t N where N is the number of cores used is always necessary for tuning performance.","category":"section"},{"location":"quickguide/#Detailed-description-of-the-example","page":"Quick Guide","title":"Detailed description of the example","text":"Start julia and load the ComplexMixtures package, using:\n\nusing ComplexMixtures\n\nAnd here we will use the PDBTools package to obtain the selections of the solute and solvent molecules: \n\nusing PDBTools\n\n(see Set solute and solvent for details).\n\nThe fastest way to understand how to use this package is through an example.  \n\nLet us consider a system of three components: a protein, water, a cosolvent: TMAO (trimetylamine-N-oxyde), which is a common osmolyte known to stabilize protein structures. A picture of this system is shown below, with the protein in blue, water, and TMAO molecules. The system was constructed with Packmol and the figure was produced with VMD.\n\n<center>\n<img src=\"../figures/proteinTMAO.png\" width=60%>\n</center>\n\nWe want to study the interactions of the protein with TMAO in this example. The computation of the MDDF is performed by defining the solute and solvent selections, and running the calculation on the trajectory.","category":"section"},{"location":"quickguide/#Define-the-protein-as-the-solute","page":"Quick Guide","title":"Define the protein as the solute","text":"To define the protein as the solute, we will use the PDBTools package, which provides a handy selection syntax. First, read the PDB file using \n\natoms = read_pdb(\"./system.pdb\")\n\nThen, let us select the protein atoms (here we are using the PDBTools.select function):\n\nprotein = select(atoms, \"protein\")\n\nAnd, finally, let us use the AtomSelection function to setup the structure required by the MDDF calculation:\n\nsolute = AtomSelection(protein, nmols=1)\n\nnote: Note\nIt is necessary to indicate how many molecules (nmols=1 in this case),  so that ComplexMixtures knows that the solute is to be considered as single structure. Here there is no ambiguity, but if the solute was a micelle, for example, this option would allow  ComplexMixtures to understand that the micelle is to be considered as a single structure.","category":"section"},{"location":"quickguide/#Define-TMAO-the-solvent-to-be-considered","page":"Quick Guide","title":"Define TMAO the solvent to be considered","text":"Equivalently, the solvent is set up with:\n\ntmao = select(atoms, \"resname TMAO\")\nsolvent = AtomSelection(tmao, natomspermol=14)\n\nnote: Note\nHere we opted to provide the number of atoms of a TMAO molecules (with the natomspermol keyword). This is generally more practical for small molecules than to provide the number of molecules.","category":"section"},{"location":"quickguide/#Set-the-Trajectory-structure","page":"Quick Guide","title":"Set the Trajectory structure","text":"The solute and solvent data structures are then fed into the Trajectory data structure, together with the trajectory file name, with:\n\ntrajectory = Trajectory(\"trajectory.dcd\", solute, solvent)\n\nIn the case, the trajectory is of NAMD \"DCD\" format. All formats supported by Chemfiles  are automatically recognized. ","category":"section"},{"location":"quickguide/#Finally,-run-the-computation-and-get-the-results:","page":"Quick Guide","title":"Finally, run the computation and get the results:","text":"If default options are used (as the bin size of the histograms, read all frames without skipping any), just run the mddf with:\n\nresults = mddf(trajectory_file, solute, solvent, Options(bulk_range=(8.0, 12.0)))\n\n\nSome optional parameters for the computation are available in the Options section. Depending on the number of atoms and trajectory length, this can take a while. Computing a MDDF is much more expensive than computing a regular radial distribution function, because the normalization requires the generation of an ideal distribution of the molecules in the system.  ","category":"section"},{"location":"quickguide/#The-results-data-structure-obtained","page":"Quick Guide","title":"The results data structure obtained","text":"The results data structure contains all the results of the MDDF calculation, including:\n\nresults.d : Vector containing the distances to the solute. \n\nresults.mddf : Vector containing the minimum-distance distribution function at each distance.\n\nThat means, for example, that \n\nplot(results.d, results.mddf, xlabel=\"d / Å\", ylabel=\"mddf(d)\") \n\n\nresults in the expected plot of the MDDF of TMAO as a function of the distance to the protein:\n\n<center>\n<img src=\"../figures/mddf.png\" width=\"60%\">\n</center>\n\nThe Kirkwood-Buff integral corresponding to that distribution is provided in the results.kb vector, and can be also directly plotted  with   \n\nplot(results.d, results.kb, xlabel=\"d / Å\", ylabel=\"KB(d) / L / mol\") \n\nto obtain:\n\n<center>\n<img src=\"../figures/kb.png\" width=\"60%\">\n</center>\n\nSee the Atomic and group contributions section for a detailed account on how to obtain a molecular picture of the solvation by splitting the MDDF in the contributions of each type of atom of the solvent, each type of residue of the protein, etc.","category":"section"},{"location":"quickguide/#Save-the-results","page":"Quick Guide","title":"Save the results","text":"The results can be saved into a file (with JSON format) with:\n\nsave(\"./results.json\", results)\n\nAnd these results can be loaded afterwards with:\n\nload(\"./results.json\")\n\nAlternatively, a human-readable set of output files can be obtained to be analyzed in other software (or plotted with alternative tools), with\n\nwrite(\"./results.dat\", results)","category":"section"},{"location":"selection/#selections","page":"Set solute and solvent","title":"Solute and solvent selections","text":"The solute and solvent are defined by selecting subsets of atoms from the  system. These subsets are defined by the AtomSelection data structures. \n\nTo construct a AtomSelection data structure, one needs to provide, at least, the (1-based) indices of the atoms that belong to the selection, and either the number of atoms of each molecule or the number of molecules in the selection.\n\nAlternatively, and more practically, atom selections defined by the PDBTools package, which can interface with the selection syntax of VMD, can be used, as described in the following sections.","category":"section"},{"location":"selection/#Using-the-PDBTools-package","page":"Set solute and solvent","title":"Using the PDBTools package","text":"The PDBTools package helps the construction of  the solute and solvent data structures, by providing a convenient selection syntax. Additionally, it sets up the names of the atoms of the system in the data structure, which can be used to retrieve atom and and group contributions to MDDFs and coordination numbers. \n\nFor example, here we define a protein of a system as the solute:\n\njulia> using ComplexMixtures, PDBTools\n\njulia> atoms = read_pdb(ComplexMixtures.pdb_file_example);\n\njulia> protein = select(atoms, \"protein\");\n\njulia> solute = AtomSelection(protein, nmols=1)\nAtomSelection \n    1463 atoms belonging to 1 molecule(s).\n    Atoms per molecule: 1463\n    Number of groups: 1463 \n\nWe need to inform the AtomSelection function about the number of atoms of each molecule (using natomspermol=3, for example), or the number  of molecules (using nmols=1000, for example), such that the atoms belonging to each molecule can be determined without ambiguity. \n\nNow, we define the solvent of the system as the water molecules:\n\njulia> water = select(atoms, \"water\"); \n\njulia> solvent = AtomSelection(water, natomspermol=3)\nAtomSelection \n    58014 atoms belonging to 19338 molecule(s).\n    Atoms per molecule: 3\n    Number of groups: 3","category":"section"},{"location":"selection/#Using-VMD","page":"Set solute and solvent","title":"Using VMD","text":"VMD is a very popular and powerful package for visualization of simulations. It contains a very versatile library to read topologies and trajectory files, and a powerful selection syntax. The PDBTools.jl (v1.0 or greater) package provides a simple wrapper to VMD that allows using the same syntax at it supports.\n\nFor example, the solute can be defined with: \n\nusing ComplexMixtures, PDBTools\n\natoms = read_pdb(\"system.pdb\")\n\nindices, names = select_with_vmd(\"./system.pdb\", \"protein\", vmd=\"/usr/bin/vmd\")\n\nprotein = atoms[indices]\n\nsolute = AtomSelection(protein, nmols=1)\n\nThe main advantage here is that all the file types that VMD supports are supported. But VMD needs to be installed and is run in background, and it takes a few seconds to be executed. \n\nThe VMDSelect function also accepts an optional keyword parameter srcload, which can be used to load custom scripts within vmd before setting the selection. This allows the definition of tcl scripts with custom selection macros, for instance. The usage would be: \n\nusing PDBTools\n\nindices, names = select_with_vmd(\n    \"file.pdb\", \n    \"resname MYRES\"; \n    srcload = [ \"mymacros1.tcl\", \"mymacros2.tcl\" ]\n)\n\nWhich corresponds to sourceing each of the macro files in VMD before defining the  selection with the custom MYRES name.\n\nwarning: Warning\nVMD uses 0-based indexing and VMDselect adjusts that. However, if a selection is performed by index, as with index 1, VMD will select the second atom, and the output will be [2]. AtomSelections by type, name, segment, residue name, etc, won't be a problem.","category":"section"},{"location":"selection/#predefinition-of-groups","page":"Set solute and solvent","title":"Predefinition of atom groups","text":"Importantly, this should be only a concern for the solvation analysis of systems in which individual molecules are very large. This feature was introduced in version 2.0 of the package to support the study of small molecule distribution in virus structures, of millions of atoms.  \n\nBy default, the contribution of each type of atom to the coordination number counts is stored, to allow the decomposition of the final MDDFs into any group contribution. However, when a structure, like a virus, has millions of atoms, storing the contribution of each atom becomes prohibitive in terms of memory. Thus, one may need to predefine the groups in which the contributions will be analyzed.\n\nHere, we illustrate this feature by presselecting the acidic and basic residues of a protein:\n\njulia> using ComplexMixtures, PDBTools\n\njulia> atoms = read_pdb(ComplexMixtures.pdb_file_example);\n\njulia> protein = select(atoms, \"protein\");\n\njulia> acidic_residues = select(atoms, \"protein and acidic\");\n\njulia> basic_residues = select(atoms, \"protein and basic\");\n\njulia> solute = AtomSelection(\n        protein, \n        nmols=1,\n        group_atom_indices = [ index.(acidic_residues), index.(basic_residues) ],\n        group_names = [ \"acidic residues\", \"basic residues\" ]\n    )\nAtomSelection \n    1463 atoms belonging to 1 molecule(s).\n    Atoms per molecule: 1463\n    Number of groups: 2 \n\nIn this example, then, the solute AtomSelection has two groups. The indices of the atoms of the groups are stored in the group_atom_indices vector and the group names in the group_names vector. The atom_group auxiliary function is the most practical way to retrieve the indices of the atoms of the group.\n\njulia> atom_group(solute, \"acidic residues\")\n162-element Vector{Int64}:\n   24\n   25\n   26\n    ⋮\n 1436\n 1437\n\nWith these group selections predefined, the contributions of these groups to the MDDF or coordination numbers can be retrieved directly from the result data structure with, for example:\n\njulia> result = mddf(trajectory_file, solute, solvent, Options(bulk_range=(8.0, 12.0)));\n\njulia> acidic_residue_contributions = contributions(result, SoluteGroup(\"acidic residues\"))","category":"section"},{"location":"selection/#ComplexMixtures.AtomSelection","page":"Set solute and solvent","title":"ComplexMixtures.AtomSelection","text":"struct AtomSelection\n\nStructure that contains the information about the solute and solvent molecules.\n\nnmols::Int64\nnatomspermol::Int64\nindices::Vector{Int64}\ncustom_groups::Bool\ngroup_atom_indices::Vector{Vector{Int64}}\ngroup_names::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"selection/#ComplexMixtures.AtomSelection-Tuple{Any}","page":"Set solute and solvent","title":"ComplexMixtures.AtomSelection","text":"AtomSelection constructors\n\nThe AtomSelection structure carries the information of the molecules that are going to be used to compute the MDDF. The structure can be initialized in different ways:\n\nInitialize the structure providing a vector of PDBTools.Atom(s).\n\nAtomSelection(\n    atoms::AbstractVector{<:PDBTools.Atom}; \n    nmols::Integer = 0, \n    natomspermol::Integer = 0,\n    group_atom_indices::Union{Nothing,Vector{<:Vector{<:Int}}} = nothing,\n    group_names::Vector{<:AbstractString} = String[]\n)\n\nThe indices of the atoms will be retrieved from the indices of the atoms as defined in the PDB file, thus the PDB file must correspond to the same system as that of the simulation. \n\nEither the number of molecules (nmols) or the number of atoms per molecule (natomspermol) must be provided.\n\nIf group_atom_indices is nothing or group_names is empty, the names of the groups will be retrieved from the atom names, and in the coordination numbers of each individual atom will be  stored.\n\nExample\n\njulia> using ComplexMixtures, PDBTools\n\njulia> pdbfile = ComplexMixtures.pdb_file_example;\n\njulia> atoms = PDBTools.read_pdb(pdbfile, \"resname TMAO\");\n\njulia> atsel = AtomSelection(atoms, natomspermol=14)\nAtomSelection \n    2534 atoms belonging to 181 molecule(s).\n    Atoms per molecule: 14\n    Number of groups: 14 \n\njulia> atom_group_name(atsel, 1)\n\"N\"\n\njulia> atom_group_name(atsel, 5)\n\"O1\"\n\njulia> length(atom_group_names(atsel))\n14\n\nLower level: initialize the structure providing the index of atoms and groups.\n\nAtomSelection(\n    indices::AbstractVector{<:Integer};\n    nmols::Int = 0,\n    natomspermol::Int = 0,\n    group_atom_indices::Union{Nothing,AbstractVector{<:AbstractVector{<:Int}}} = nothing,\n    group_names::AbstractVector{<:AbstractString} = String[]\n)\n\nConstruct an AtomSelection structure from the most low-level information: the index of atoms and groups.\n\nEither the number of molecules (nmols) or the number of atoms per molecule (natomspermol) must be provided.\n\nGroups of atoms can be defined by providing a vector of vectors of atom indices (group_atom_indices), and a vector of group names (group_names). If group_atom_indices is set to nothing, the coordination numbers of each individual atoms will be stored.\n\nExamples\n\njulia> using ComplexMixtures\n\njulia> AtomSelection([1,2,3], nmols=1)\nAtomSelection \n    3 atoms belonging to 1 molecule(s).\n    Atoms per molecule: 3\n    Number of groups: 3\n\njulia> AtomSelection([1,2,3], natomspermol=1)\nAtomSelection \n    3 atoms belonging to 3 molecule(s).\n    Atoms per molecule: 1\n    Number of groups: 1\n\njulia> AtomSelection([1,2,3], natomspermol=1, group_atom_indices=[[1,2],[3]], group_names=[\"G1\", \"G2\"])\nAtomSelection \n    3 atoms belonging to 3 molecule(s).\n    Atoms per molecule: 1\n    Number of groups: 2 \n\n\n\n\n\n","category":"method"},{"location":"selection/#ComplexMixtures.atom_group","page":"Set solute and solvent","title":"ComplexMixtures.atom_group","text":"atom_group(atsel::AtomSelection, i::Integer)\natom_group(atsel::AtomSelection, groupname::String)\n\natom_group(atsel::AtomSelection, i::Int)\natom_group(atsel::AtomSelection, groupname::String)\n\nReturn the indices of the atoms that belong to a given group, when custom groups where defined.\n\nExample\n\njulia> using ComplexMixtures\n\njulia> atsel = AtomSelection([1,2,3], natomspermol=1, group_atom_indices=[[1,2],[3]], group_names=[\"G1\", \"G2\"])\nAtomSelection \n    3 atoms belonging to 3 molecule(s).\n    Atoms per molecule: 1\n    Number of groups: 2\n\njulia> atom_group(atsel, 1)\n2-element Vector{Int64}:\n 1\n 2\n\njulia> atom_group(atsel, \"G2\")\n1-element Vector{Int64}:\n 3\n\njulia> atom_group_name(atsel, 1)\n\"G1\"\n\n\n\n\n\n","category":"function"},{"location":"selection/#ComplexMixtures.atom_group_name","page":"Set solute and solvent","title":"ComplexMixtures.atom_group_name","text":"atom_group_name(atsel::AtomSelection, i::Integer)\natom_group_names(atsel::AtomSelection)\n\nReturn the name of the group of atoms with index i.  The atom_group_names function returns a vector with the names of all the groups.\n\nExample\n\njulia> using ComplexMixtures\n\njulia> atsel = AtomSelection([1,2,3], natomspermol=1, group_atom_indices=[[1,2],[3]], group_names=[\"G1\", \"G2\"])\nAtomSelection \n    3 atoms belonging to 3 molecule(s).\n    Atoms per molecule: 1\n    Number of groups: 2\n\njulia> atom_group_name(atsel, 1)\n\"G1\"\n\njulia> atom_group_names(atsel)\n2-element Vector{String}:\n \"G1\"\n \"G2\"\n\n\n\n\n\n","category":"function"},{"location":"selection/#ComplexMixtures.atom_group_names","page":"Set solute and solvent","title":"ComplexMixtures.atom_group_names","text":"atom_group_name(atsel::AtomSelection, i::Integer)\natom_group_names(atsel::AtomSelection)\n\nReturn the name of the group of atoms with index i.  The atom_group_names function returns a vector with the names of all the groups.\n\nExample\n\njulia> using ComplexMixtures\n\njulia> atsel = AtomSelection([1,2,3], natomspermol=1, group_atom_indices=[[1,2],[3]], group_names=[\"G1\", \"G2\"])\nAtomSelection \n    3 atoms belonging to 3 molecule(s).\n    Atoms per molecule: 1\n    Number of groups: 2\n\njulia> atom_group_name(atsel, 1)\n\"G1\"\n\njulia> atom_group_names(atsel)\n2-element Vector{String}:\n \"G1\"\n \"G2\"\n\n\n\n\n\n","category":"function"},{"location":"example4/#Glycerol/water-mixture","page":"Water/Glycerol mixture","title":"Glycerol/water mixture","text":"This example illustrates the use of ComplexMixtures.jl to study the solution structure of a crowded (1:1 molar fraction) solution of glycerol in water. Here, we compute the distribution function and atomic contributions associated to the inter-species interactions (water-glycerol) and the glycerol-glycerol auto-correlation function. This example aims to illustrate how to obtain a detailed molecular picture of the solvation structures in an homogeneous mixture.\n\nThe system simulated consists of 1000 water molecules (red) and 1000 glycerol molecules (purple).\n\n<center>\n<img src=\"../figures/glyc_wat_system.png\" width=30%>\n</center>","category":"section"},{"location":"example4/#Index","page":"Water/Glycerol mixture","title":"Index","text":"Data, packages, and execution\nGlycerol-Glycerol and Water-Glycerol distribution functions\nGlycerol group contributions to MDDFs\n2D map of group contributions","category":"section"},{"location":"example4/#data-example4","page":"Water/Glycerol mixture","title":"Data, packages, and execution","text":"The files required to run this example are available at [this link], and are: \n\nequilibrated.pdb: The PDB file of the complete system.\ntraj_Glyc.dcd: Trajectory file. This is a 200Mb file, necessary for running from scratch the calculations.\n\nTo run the scripts, we suggest the following procedure:\n\nCreate a directory, for example example4.\nUnzip and copy the required data files above to this directory.\nLaunch julia in that directory: activate the directory environment, and install the required packages. This launching Julia and executing:\nimport Pkg \nPkg.activate(\".\")\nPkg.add([\"ComplexMixtures\", \"PDBTools\", \"Plots\", \"LaTeXStrings\", \"EasyFit\"])\nexit()\nCopy the code of each script in to a file, and execute with:\njulia -t auto script.jl\nAlternatively (and perhaps preferably), copy line by line the content of the script into the Julia REPL, to follow each step of the calculation.","category":"section"},{"location":"example4/#glyc_mddf-example4","page":"Water/Glycerol mixture","title":"Glycerol-Glycerol and Water-Glycerol distribution functions","text":"The first and most simple analysis is the computation of the minimum-distance distribution functions between the components of the solution. In this example we focus on the distributions of the two components relative to the glycerol molecules. Thus, we display the glycerol auto-correlation function, and the water-glycerol correlation function in the first panel of the figure below. The second panel displays the KB integrals of the two components computed from each of these distributions.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example4/script1.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )\n\nBoth water and glycerol form hydrogen bonds with (other) glycerol molecules, as indicated by the peaks at ~1.8mathrmAA. The auto-correlation function of glycerol shows a more marked second peak corresponding to non-specific interactions, which (as we will show) are likely associated to interactions of its aliphatic groups.\n\nThe KB integrals in the second panel show similar values water and glycerol, with the KB integral for water being slightly greater. This means that glycerol molecules are (sightly, if the result is considered reliable) preferentially hydrated from a macroscopic standpoint.","category":"section"},{"location":"example4/#glyc-groups-example4","page":"Water/Glycerol mixture","title":"Glycerol group contributions to MDDFs","text":"<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example4/script2.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )","category":"section"},{"location":"example4/#map-example4","page":"Water/Glycerol mixture","title":"2D map of group contributions","text":"The above distributions can be split into the contributions of each glycerol chemical group. The 2D maps below display this decomposition.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example4/script3.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )\n\nThe interesting result here is that the mathrmCH group of glycerol is protected from both solvents. There is a strong density augmentation at the vicinity of hydroxyl groups, and the second peak of the MDDFs is clearly associated to interactions with the mathrmCH_2 groups.","category":"section"},{"location":"example2/#Polyacrylamide-in-DMDF","page":"Polyacrylamide in DMF","title":"Polyacrylamide in DMDF","text":"In this example we illustrate how the solvation structure of a polymer can be studied with ComplexMixtures.jl. The system is a 5-mer segment of polyacrylamide (PAE - capped with methyl groups), solvated with dimethylformamide (DMF). The system is interesting because of the different functional groups and polarities involved in the interactions of DMF with PAE. A snapshot of the system is shown below.\n\n<center>\n<img width=30% src=\"../figures/poly_dmf_system.png\">\n</center>\n\nThe structures of DMF and of the polyacrylamide segment are:\n\n<center>\n<table><tr>\n<td><img src=\"../figures/dmf.png\" height=100px></td>\n<td><img src=\"../figures/polyacrylamide.png\" height=100px></td>\n</tr>\n<tr>\n<td align=center>DMF</td>\n<td align=center>Polyacrylamide</td>\n</tr>\n</table>\n</center>","category":"section"},{"location":"example2/#Index","page":"Polyacrylamide in DMF","title":"Index","text":"Data, packages, and execution\nMDDF and KB integrals\nGroup contributions\n2D density map","category":"section"},{"location":"example2/#data-example2","page":"Polyacrylamide in DMF","title":"Data, packages, and execution","text":"The files required to run this example are available at [this link], and are: \n\nequilibrated.pdb: The PDB file of the complete system.\ntraj_Polyacry.dcd: Trajectory file. This is a 275Mb file, necessary for running from scratch the calculations.\n\nTo run the scripts, we suggest the following procedure:\n\nCreate a directory, for example example2.\nUnzip and copy the required data files above to this directory.\nLaunch julia in that directory: activate the directory environment, and install the required packages. This launching Julia and executing:\nimport Pkg \nPkg.activate(\".\")\nPkg.add([\"ComplexMixtures\", \"PDBTools\", \"Plots\", \"LaTeXStrings\", \"EasyFit\"])\nexit()\nCopy the code of each script in to a file, and execute with:\njulia -t auto script.jl\nAlternatively (and perhaps preferably), copy line by line the content of the script into the Julia REPL, to follow each step of the calculation.","category":"section"},{"location":"example2/#mddf-example2","page":"Polyacrylamide in DMF","title":"MDDF and KB integrals","text":"Here we compute the minimum-distance distribution function, the Kirkwood-Buff integral, and the atomic contributions of the solvent to the density. This example illustrates the regular usage of ComplexMixtures, to compute the minimum distance distribution function, KB-integrals and group contributions. \n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example2/script1.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>","category":"section"},{"location":"example2/#Output","page":"Polyacrylamide in DMF","title":"Output","text":"The distribution of DMF molecules around polyacrylamide is shown below. There is a peak at ~2.5Angs, indicating favorable non-specific interactions between the solvent molecules and the polymer. The peak is followed by a dip and diffuse peaks at higher distances. Thus, the DMF molecules are structured around the polymer, but essentially only in the first solvation shell.  \n\n(Image: )\n\nThe KB integral in a bicomponent mixture converges to the (negative of the) apparent molar volume of the solute. It is negative, indicating that the accumulation of DMF in the first solvation shell of the polymer is not enough to compensate the excluded volume of the solute. ","category":"section"},{"location":"example2/#groups-example2","page":"Polyacrylamide in DMF","title":"Group contributions","text":"The MDDF can be decomposed into the contributions of the DMF chemical groups, and on the polyacrylamide chemical groups. In the first panel below we show the contributions of the DMF chemical groups to the distribution function.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example2/script2.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>","category":"section"},{"location":"example2/#Output-2","page":"Polyacrylamide in DMF","title":"Output","text":"The decomposition reveals that specific interactions peaking at distances slightly smaller than 2AA exist between the polymer and the carbonyl group of DMF. Thus, there hydrogen bonds between the polymer and this group, which dominate the interactions between the solute and the solvent at short distances. The non-specific interactions peak at 2.5Angs and are composed of contributions of all DMF chemical groups, but particularly of the methyl groups.\n\n(Image: )\n\nThe decomposition of the same MDDF in the contributions of the chemical groups of the polymer is clearly associated to the DMF contributions. The specific, hydrogen-bonding, interactions, are associated to the polymer amine groups. The amine groups also contribute to the non-specific interactions at greater distances, but these are a sum of the contributions of all polymer groups, polar or aliphatic.","category":"section"},{"location":"example2/#2Dmap-example2","page":"Polyacrylamide in DMF","title":"2D density map","text":"We can decompose the MDDF into the contributions of each portion of the polymer chain. The map below displays the contributions of each chemical group of the polymer, now split into the mers of the polymer, to the MDDF.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example2/script3.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>","category":"section"},{"location":"example2/#Output-3","page":"Polyacrylamide in DMF","title":"Output","text":"The terminal methyl groups interact strongly with DMF, and strong local density augmentations are visible in particular on the amine groups. These occur at less than 2.0Angs and are characteristic of hydrogen-bond interactions. Interestingly, the DMF molecules are excluded from the aliphatic and carbonyl groups of the polymer, relative to the other groups.\n\nFinally, it is noticeable that the central mer is more weakly solvated by DMF than the mers approaching the extremes of the polymer chain. This is likely a result of the partial folding of the polymer, that protects that central mers from the solvent in a fraction of the polymer configurations.\n\n<center>\n<img width=70% src=\"../assets/scripts/example2/map2D_acr.png\">\n</center>","category":"section"},{"location":"example2/#References","page":"Polyacrylamide in DMF","title":"References","text":"Molecules built with JSME: B. Bienfait and P. Ertl, JSME: a free molecule editor in JavaScript, Journal of Cheminformatics 5:24 (2013) http://biomodel.uah.es/en/DIY/JSME/draw.en.htm\n\nThe system was built with Packmol.\n\nThe simulations were performed with NAMD, with CHARMM36 parameters. ","category":"section"},{"location":"example3/#POPC-membrane-in-water/ethanol","page":"POPC membrane in water/ethanol","title":"POPC membrane in water/ethanol","text":"In this example ComplexMixtures.jl is used to study the interactions of a POPC membrane with a mixture of 20%(mol/mol) ethanol in water. At this concentration ethanol destabilizes the membrane.\n\n<center>\n<img width=50% src=\"../figures/popc_water_ethanol_system.png\">\n</center>\n\nSystem image: a POPC membrane (center) solvated by a mixture of water (purple) and ethanol (green). The system is composed by 59 POPC, 5000 water, and 1000 ethanol molecules.  ","category":"section"},{"location":"example3/#Index","page":"POPC membrane in water/ethanol","title":"Index","text":"Data, packages, and execution\nMDDF and KB integrals\nGroup contributions\nInteraction of POPC groups with water\nInteraction of POPC groups with ethanol\nDensity map on POPC chains","category":"section"},{"location":"example3/#data-example3","page":"POPC membrane in water/ethanol","title":"Data, packages, and execution","text":"The files required to run this example are available at [this link], and are: \n\nequilibrated.pdb: The PDB file of the complete system.\ntraj_POPC.dcd: Trajectory file. This is a 365Mb file, necessary for running from scratch the calculations.\n\nTo run the scripts, we suggest the following procedure:\n\nCreate a directory, for example example3.\nUnzip and copy the required data files above to this directory.\nLaunch julia in that directory: activate the directory environment, and install the required packages. This launching Julia and executing:\nimport Pkg \nPkg.activate(\".\")\nPkg.add([\"ComplexMixtures\", \"PDBTools\", \"Plots\", \"LaTeXStrings\", \"EasyFit\"])\nexit()\nCopy the code of each script in to a file, and execute with:\njulia -t auto script.jl\nAlternatively (and perhaps preferably), copy line by line the content of the script into the Julia REPL, to follow each step of the calculation.","category":"section"},{"location":"example3/#mddf-example3","page":"POPC membrane in water/ethanol","title":"MDDF and KB integrals","text":"Here we show the distribution functions and KB integrals associated to the solvation of the membrane by water and ethanol. \n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example3/script1.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>","category":"section"},{"location":"example3/#Output","page":"POPC membrane in water/ethanol","title":"Output","text":"The distribution functions are shown in the first panel of the figure below, and the KB integrals are shown in the second panel.\n\n(Image: )\n\nClearly, both water and ethanol accumulate on the proximity of the membrane. The distribution functions suggest that ethanol displays a greater local density augmentation, reaching concentrations roughly 4 times higher than bulk concentrations. Water has a peak at hydrogen-bonding distances (~1.8mathrmAA) and a secondary peak at 2.5mathrmAA.\n\nDespite the fact that ethanol displays a greater relative density (relative to its own bulk concentration) at short distances, the KB integral of water turns out to be greater (more positive) than that of ethanol. This implies that the membrane is preferentially hydrated.","category":"section"},{"location":"example3/#groups1-example3","page":"POPC membrane in water/ethanol","title":"Ethanol group contributions","text":"The minimum-distance distribution function can be decomposed into the contributions of the ethanol molecule groups. \n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example3/script2.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\nIn the figure below we show the contributions of the ethanol hydroxyl and aliphatic chain groups to the total MDDF.\n\n(Image: )\n\nAs expected, the MDDF at hydrogen-bonding distances is composed by contributions of the ethanol hydroxyl group, and the non-specific interactions at ~2.5mathrmAA have a greater contribution of the aliphatic chain of the solvent molecules. It is interesting to explore the chemical complexity of POPC in what concerns these interactions.","category":"section"},{"location":"example3/#groups2-example3","page":"POPC membrane in water/ethanol","title":"Interaction of POPC groups with water","text":"The MDDF can also be decomposed into the contributions of the solute atoms and chemical groups. First, we show the contributions of the POPC chemical groups to the water-POPC distribution.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example3/script3.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )\n\nNot surprisingly, water interactions occur majoritarily with the Phosphate and Choline groups of POPC molecules, that is, with the polar head of the lipid. The interactions at hydrogen-bonding distances are dominated by the phosphate group, and non-specific interaction occur mostly with the choline group. Some water molecules penetrate the membrane and interact with the glycerol and aliphatic chains of POPC, but these contributions are clearly secondary.","category":"section"},{"location":"example3/#groups3-example3","page":"POPC membrane in water/ethanol","title":"Interaction of POPC groups with ethanol","text":"The interactions of ethanol molecules with the membrane are more interesting, because ethanol penetrates the membrane. Here we decompose the ethanol-POPC distribution function into the contributions of the POPC chemical groups.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example3/script4.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )\n\nEthanol molecules interact with the choline and phosphate groups of POPC molecules, as do water molecules. The contributions to the MDDF at hydrogen-bonding distances come essentially from ethanol-phosphate interactions.\n\nHowever, ethanol molecules interact frequently with the glycerol and aliphatic chains of POPC. Interactions with the Oleoyl chain are slightly stronger than with the Palmitoyl chain. This means that ethanol penetrates the hydrophobic core of the membrane, displaying non-specific interactions with the lipids and with the glycerol group. These interactions are probably associated to the destabilizing role of ethanol in the membrane structure.","category":"section"},{"location":"example3/#map-example3","page":"POPC membrane in water/ethanol","title":"Density map on POPC chains","text":"The MDDFs can be decomposed at more granular level, in which each chemical group of the aliphatic chains of the POPC molecules are considered independently. This allows the study of the penetration of the ethanol molecules in the membrane. In the figure below, the carbonyl following the glycerol group of the POPC molecules is represented in the left, and going to the right the aliphatic chain groups are sequentially shown.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`julia\n$(read(\"./assets/scripts/example3/script5.jl\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )\n\nEthanol displays an important density augmentation at the vicinity of the carbonyl that follows the glycerol group, and accumulates on the proximity of the aliphatic chain. The density of ethanol decreases as one advances into the aliphatic chain, displaying a minimum around the insaturation in the Oleoyl chain. The terminal methyl group of both chains display a greater solvation by ethanol, suggesting the twisting of the aliphatic chain expose these terminal groups to membrane depth where ethanol is already abundant.\n\nThe equivalent maps for water are strikingly different, and show that water is excluded from the interior of the membrane:\n\n(Image: )","category":"section"},{"location":"example3/#References","page":"POPC membrane in water/ethanol","title":"References","text":"Membrane built with the VMD membrane plugin. \n\nWater and ethanol layers added with Packmol.\n\nThe simulations were performed with NAMD, with CHARMM36 parameters. \n\nDensity of the ethanol-water mixture from: https://wissen.science-and-fun.de/chemistry/chemistry/density-tables/ethanol-water-mixtures/","category":"section"},{"location":"tools/#Tools","page":"Tools","title":"Coordination numbers","text":"Computing radial distribution functions\nOverview of the solvent and solute properties","category":"section"},{"location":"tools/#radial_distribution","page":"Tools","title":"Computing radial distribution functions","text":"The distributions returned by the mddf function (the mddf and rdf vectors), are normalized by the random reference state. This is equivalent to  a site count based on the numerical integration of the volume corresponding to each minimum-distance to the solute. \n\nIf, however, the solute is defined by a single atom (as the oxygen atom of water, for example), the numerical integration of the volume can be replaced by a simple analytical spherical shell volume, reducing noise. The ComplexMixtures.gr function returns the radial distribution function and the KB integral  computed from the results, using this volume estimate: \n\ng, kb = ComplexMixtures.gr(R)\n\nBy default, the single-reference count (rdf_count) of the Result structure will be used to compute the radial distribution function. The function can be called with explicit control of all input parameters: \n\ng, kb = ComplexMixtures.gr(r,count,density,binstep)\n\nwhere:\n\nParameter Definition Result structure output data to provide\nr Vector of distances The d vector\ncount Number of site counts at each r The rdf or mddf vectors\ndensity Bulk density The density.solvent_bulk or density.solvent densities.\nbinstep The histogram step The options.binstep\n  \n\nExample:\n\n...\nR = mddf(trajectory_file, solute, solvent, options)\ng, kb = ComplexMixtures.gr(R.d,R.rdf_count,R.density.solvent_bulk,R.options.binstep)","category":"section"},{"location":"tools/#overview","page":"Tools","title":"Overview of the solvent and solute properties","text":"The output to the REPL of the Result structure provides an overview of the properties of the solution. The data can be retrieved into a data structure using the overview function. Examples:     \n\n...\n\njulia> results = mddf(trajectory_file, solute, solvent, Options(bulk_range=(8.0, 12.0)))\n\njulia> results\n--------------------------------------------------------------------------------\nMDDF Overview - ComplexMixtures - Version 2.0.8\n--------------------------------------------------------------------------------\n\nSolvent properties:\n-------------------\n\nSimulation concentration: 0.49837225882780106 mol L⁻¹\nMolar volume: 2006.532230249041 cm³ mol⁻¹\n\nConcentration in bulk: 0.5182380507741433 mol L⁻¹\nMolar volume in bulk: 1929.6151614228274 cm³ mol⁻¹\n\nSolute properties:\n------------------\n\nSimulation Concentration: 0.002753437894076249 mol L⁻¹\nEstimated solute partial molar volume: 13921.98945754469 cm³ mol⁻¹\n\nBulk range: 8.0 - 12.0 Å\nMolar volume of the solute domain: 34753.1382279134 cm³ mol⁻¹\n\nAuto-correlation: false\n\nTrajectory files and weights:\n\n   /home/user/NAMD/trajectory.dcd - w = 1.0\n\nLong range MDDF mean (expected 1.0): 1.0378896753018338 ± 1.0920172247127446\nLong range RDF mean (expected 1.0): 1.2147429551790854 ± 1.2081838161780682\n\n--------------------------------------------------------------------------------\n\nIn this case, since solute and solvent are equivalent and the system is homogeneous, the molar volumes and concentrations are similar. This is not the case if the molecules are different or if the solute is at infinite dilution (in which case the bulk solvent density might be different from the solvent density in the simulation). \n\nTo retrieve the data of the overview structure use, for example:\n\njulia> overview = overview(results);\n\njulia> overview.solute_molar_volume\n657.5051512801567","category":"section"},{"location":"tools/#renormalize","page":"Tools","title":"Renormalization of bulk density","text":"The renormalize function allows to renormalize the Result structure to a different bulk density of the solvent. This is useful in cases where the bulk density cannot be estimated from the simulation, for example in simulations of zeolites, MOFs, etc, where the solvent is confined within a porous material and there's no bulk region.\n\nUnder the hood, the function rescales the site count of the reference (ideal gas) distribution used for normalization.\n\nTypically, the MDDF would be computed with an arbitrary bulk region and renormalized using the density of the solvent in the complete simulation box, or the density of pure solvent.\n\nwarning: Warning\nIn these situations the computation of KB integrals, apparent molar volumes, and preferential interactions might not be meaningful, but the MDDF and RDF can still provide useful information about the local structure of the solvent around the solute.","category":"section"},{"location":"tools/#ComplexMixtures.gr-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, Real, Real}","page":"Tools","title":"ComplexMixtures.gr","text":"gr(r::AbstractVector{<:Real}, count::AbstractVector{<:Real}, density::Real, binstep::Real)\n\nComputes the radial distribution function from the count data and the density.\n\nThis is exactly a conventional g(r) if a single atom was chosen as the solute and solvent selections.\n\nReturns both the g(r) and the kb(r)\n\n\n\n\n\n","category":"method"},{"location":"tools/#ComplexMixtures.gr-Tuple{Result}","page":"Tools","title":"ComplexMixtures.gr","text":"gr(R::Result) = gr(R.d,R.rdf_count,R.density.solvent_bulk,R.files[1].options.binstep)\n\nIf a Result structure is provided without further details, use the rdf count and the bulk solvent density.\n\n\n\n\n\n","category":"method"},{"location":"tools/#ComplexMixtures.renormalize","page":"Tools","title":"ComplexMixtures.renormalize","text":"renormalize(R::Result, bulk_density::Number, unit::String=\"mol/L\"; silent=true)\n\nRenormalizes the Result structure R to a different bulk density of the solvent. The unit argument can be either \"mol/L\" or \"sites/Angs3\" (default is \"mol/L\").\n\nThis function does not modify the input Result structure, but returns a new one.\n\nExample\n\nIn the following example we multiply the density of the bulk solvent by 2, causing the decrease of the MDDF by a factor of 2. The KB integrals will be also updated  accordingly.\n\njulia> using ComplexMixtures\n\njulia> R = load(ComplexMixtures.data_dir*\"/NAMD/protein_tmao.json\");\n\njulia> R_new = renormalize(R, 2*R.density.solvent_bulk, \"sites/Angs3\");\n\njulia> R_new.mddf ≈ 0.5 * R.mddf\ntrue\n\nThe silent keyword argument controls whether warnings are printed associated to bins with zero samples in the ideal-gas histogram.\n\n\n\n\n\n","category":"function"},{"location":"updating_scripts/#updating-scripts","page":"Updating scripts from v1 to v2","title":"Updating scripts from v1 to v2","text":"The syntax chances necessary to update script from version 1.X to 2.X of  the package are:","category":"section"},{"location":"updating_scripts/#Atom-selections","page":"Updating scripts from v1 to v2","title":"Atom selections","text":"The previous Selection structure was renamed to AtomSelection for clarity.\n\nBefore:\n\nwater = Selection(water; natomspermol=3)\n\nNow:\n\nwater = AtomSelection(water; natomspermol=3)","category":"section"},{"location":"updating_scripts/#Group-contributions-syntax","page":"Updating scripts from v1 to v2","title":"Group contributions syntax","text":"The syntax to computing group contributions is improved. Previously, the contrib or contributions functions required three somewhat redundant parameters. \n\nBefore:\n\nThe call to contributions required 3 parameters: the Selection structure, the matrix of contributions, and the indexes of the atoms for which the contributions were desired:\n\nh_contributions = contributions(solvent, R.solvent_atom, h_indexes)\n\nNow:\n\nThe contributions are extracted from the Result data structure, by  providing either a SoluteGroup or SolventGroup object, which are setup with the group names, group indexes, atom names, or atom indexes:\n\nh_contributions = contributions(R, SolventGroup(h_indexes))","category":"section"},{"location":"updating_scripts/#Frame-weights","page":"Updating scripts from v1 to v2","title":"Frame weights","text":"frame_weights is an option of the mddf execution. That is previously, they were defined in the Options data structure, and now they are passed to the mddf function.\n\nBefore:\n\noptions = Options(frame_weights=[1.0, 2.0], bulk_range=(8.0, 12.0))\nresults = mddf(trajectory_file, solute, solvent, options)\n\nNow:\n\nresults = mddf(trajectory_file, solute, solvent, options; frame_weights=[1.0, 2.0])","category":"section"},{"location":"coordination_numbers/#coordination_number","page":"Coordination numbers","title":"Coordination numbers","text":"","category":"section"},{"location":"coordination_numbers/#Extract-coordination-numbers","page":"Coordination numbers","title":"Extract coordination numbers","text":"The coordination number is the numerical count of how many molecules of a solvent is within a certain distance  from the solute. The following function provides the functionality of retrieving coordination numbers and atom groups contributions to these numbers, given a Result data structure: \n\nThe function can be called without any argument besides the Result data structure, in which case the coordination number of the complete solute will  be returned, as a function of the distance. \n\nAlternatively, subgroups of the solute or the solvent can be selected, by providing SoluteGroup or SolventGroup objects as second arguments,  initialized with the atoms of the subgroup, as a list of indices or a list of atoms generated by PDBTools. Note that, if a SolventGroup is defined we obtain the contributions of those solvent atoms to the coordination number of the solute (for instance, the sum of the contributions of all solvent atoms is the coordination number of the solute). ","category":"section"},{"location":"coordination_numbers/#Example","page":"Coordination numbers","title":"Example","text":"In the following example we compute the coordination number of the atoms of residue 50 (which belongs to the solute - a protein) with the solvent atoms of TMAO, as a function of the distance. The plot produced will show side by side the residue contribution to the MDDF and the corresponding coordination number.\n\n# Load necessary packages\nusing ComplexMixtures, PDBTools \n# Load data structure and previously computed results from a mddf calculation \npdb = read_pdb(\"test/data/NAMD/structure.pdb\")\nR = load(\"test/data/NAMD/protein_tmao.json\")\n# Define which is the solute\nsolute = AtomSelection(PDBTools.select(pdb, \"protein\"), nmols=1)\n# We intend to compute the contributions of residue 50 only\nresidue50 = PDBTools.select(pdb, \"residue 50\")\n# Compute the group contribution to the MDDF\nresidue50_contribution = contributions(R, SoluteGroup(residue50))\n# Now compute the coordination number\nresidue50_coordination = coordination_number(R, SoluteGroup(residue50))\n#\n# Plot with twin y-axis\n#\nusing Plots \nplot(R.d, residue50_contribution,\n    xaxis=\"distance / Å\", \n    yaxis=\"MDDF contribution\", \n    linewidth=2, label=nothing, color=1\n)\nplot!(twinx(),R.d, residue50_coordination, \n    yaxis=\"Coordination number\", \n    linewidth=2, label=nothing, color=2\n)\nplot!(title=\"Residue 50\", framestyle=:box, subplot=1)\n\nWith appropriate input data, this code produces:\n\n<center>\n<img width=60% src=\"../figures/coordination.png\" width=80%>\n</center>\n\ntip: Tip\nThere are some systems for which the normalization of the distributions is not  necessary or possible. It is still possible to compute the coordination numbers, by running, instead of mddf, the coordination_number function:coordination_number(trajectory_file, solute, solvent, options::Options)This call will return a Result data structure but with all fields requiring  normalization with zeros. In summary, this result data structure can be used to compute the coordination numbers, but not the MDDF, RDF, or KB integrals.\n\ncompat: Compat\nThe independent computation of coordination numbers was introduced in version 1.1.","category":"section"},{"location":"coordination_numbers/#MolSimToolkitShared.coordination_number","page":"Coordination numbers","title":"MolSimToolkitShared.coordination_number","text":"coordination_number(R::Result) = R.coordination_number\ncoordination_number(R::Result, s::Union{SoluteGroup,SolventGroup})\n\nHere, the coordination number is the number of molecules of the solvent that are within a certain distance from the solute.\n\nIf no group is defined (first call above), the coordination number of the whole solute or solvent is returned.\n\nIf a group is defined (second call above), the contributions of this group of atoms to the coordination number are  returned, as a function of the distance to the solute: \n\nR are the results obtained, that is, a Result data structure,\ns is the solute or solvent selection (of type ComplexMixtures.AtomSelection)\n\nExamples\n\nCoordination number of a subgroup of atoms of the solute\n\nHere we compute the coordination number of the atoms of the Alanine residues of a protein, relative to the solvent (TMAO), as a function of the distance. For simplicity, the  coordination number at 5 Å is shown. We use, in this case, the SoluteGroup type to define the group of atoms, providing select(ats, \"resname ALA\") as the selection of atoms of the solute. select is a  function from the PDBTools package. \n\njulia> using ComplexMixtures, PDBTools\n\njulia> using ComplexMixtures: data_dir\n\njulia> ats = read_pdb(joinpath(data_dir,\"NAMD/structure.pdb\"));\n\njulia> solute = AtomSelection(select(ats, \"protein\"); nmols=1);\n\njulia> solvent = AtomSelection(select(ats, \"resname TMAO\"); natomspermol=14);\n\njulia> R = mddf(\n           joinpath(data_dir,\"NAMD/trajectory.dcd\"), \n           solute, \n           solvent, \n           Options(bulk_range=(8.0,12.0), silent=true)\n        );\n\njulia> i5 = findfirst(>=(5), R.d) # index for distance ≈ 5 Å\n251\n\njulia> ala_residues = select(ats, \"resname ALA\");\n\njulia> coordination_number(R, SoluteGroup(ala_residues))[i5]\n0.45\n\nAlternatively to the use of the PDBTools.select function, an array with the indices of the atoms of the protein can be used to define the solute group, as, for example:\n\njulia> ala_indices = findall(at -> resname(at) == \"ALA\", ats);\n\njulia> coordination_number(R, SoluteGroup(ala_indices))[i5]\n0.45\n\nA similar syntax can be used to compute contributions of the solvent atoms to the MDDF.\n\nCoordination numbers if the groups are predefined\n\nIf group contributions were precomputed, the name of the group can be used to compute the coordination number:\n\njulia> using ComplexMixtures, PDBTools\n\njulia> using ComplexMixtures: data_dir\n\njulia> ats = read_pdb(joinpath(data_dir,\"NAMD/structure.pdb\"));\n\njulia> solute = AtomSelection(\n           select(ats, \"protein\"); \n           nmols=1,\n           # predefinition of the group of atoms:\n           group_atom_indices = [ findall(at -> resname(at) == \"ALA\", ats) ],\n           group_names = [\"alanine residues\"]\n        )\nAtomSelection \n    1463 atoms belonging to 1 molecule(s).\n    Atoms per molecule: 1463\n    Number of groups: 1\n\njulia> solvent = AtomSelection(select(ats, \"resname TMAO\"); natomspermol=14);\n\njulia> R = mddf(\n           joinpath(data_dir,\"NAMD/trajectory.dcd\"), \n           solute, \n           solvent, \n           Options(bulk_range=(8.0,12.0), silent=true)\n        );\n\njulia> i5 = findfirst(>=(5), R.d) # index for distance ≈ 5 Å\n251\n\njulia> coordination_number(R, SoluteGroup(\"alanine residues\"))[i5]\n0.45\n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Running the examples","title":"Examples","text":"","category":"section"},{"location":"examples/#List-of-examples","page":"Running the examples","title":"List of examples","text":"Protein in water/glycerol\nPolyacrylamide in DMDF\nPOPC membrane in water/ethanol\nGlycerol/water mixture","category":"section"},{"location":"examples/#How-to-run-these-examples","page":"Running the examples","title":"How to run these examples","text":"Download and install the Julia programming language.\n\nTo run the scripts, we suggest the following procedure:\n\nCreate a directory, for example example1.\nCopy the required data files, indicated in each example.\nLaunch julia in that directory, activate the directory environment, and install the required packages.  This is done by launching Julia and executing:\nimport Pkg \nPkg.activate(\".\")\nPkg.add([\"ComplexMixtures\", \"PDBTools\", \"Plots\", \"LaTeXStrings\", \"EasyFit\"])\nexit()\nCopy the code of each script in to a file, and execute with:\njulia -t auto script.jl\nAlternatively (and perhaps preferably), copy line by line the content of the script into the Julia REPL, to follow each step of the calculation. For a more advanced Julia usage, we suggest the VSCode IDE with the  Julia Language Support extension. ","category":"section"},{"location":"options/#options","page":"Options","title":"Options","text":"There are some options to control what exactly is going to be computed to obtain the MDDF. These options can be defined by the user and passed to the mddf function, using, for example: \n\noptions = Options(lastframe=1000, bulk_range=(8.0, 12.0))\nresults = mddf(trajectory_file, solute, solvent, options)","category":"section"},{"location":"options/#Frame-ranges-and-histogram-properties","page":"Options","title":"Frame ranges and histogram properties","text":"These are common options that the regular user might want to set  in their calculation.\n\nfirstframe: Integer, first frame of the trajectory to be considered.\n\nlastframe: Integer, last frame of the trajectory to be considered.\n\nstride: Integer, consider every stride frames, that is, if stride=5 only one in five frames will be considered.\n\nbinstep: Real, length of the bin step of the histograms, default = 0.02 Angstroms.\n\nbulk_range: This parameter defines the range of distances from the  solute that will be considered as the bulk region of the solution. The density of the bulk solution is estimated by counting the number of molecules of the solvent in this region, and by performing a  numerical integration of its volume. Set this range to a region of the solution where the MDDF is converged to 1 for practical purposes. Tuning this parameter is crucial for a proper convergence of the MDDFs and KB integrals. \n\ncompat: Compat\nThe bulk_range option was introduced in version 2.1.0.","category":"section"},{"location":"options/#Lower-level-options","page":"Options","title":"Lower level options","text":"These will probably never be set by the user, unless if dealing with  some special system (large very large, or very low density system).\n\ndbulk: Real, distance from which the solution is to be considered as a bulk solution, that is, where the presence of the solute does not affect the structure of the solution anymore. By default, all molecules at distances greater than 10.0 Angstroms are considered bulk molecules.  However, the definition of bulk_range is highly encouraged. \n\ncutoff: Real, the maximum distance to be considered in the construction of histograms. Default: 10 Angstroms.\n\nusecutoff: true/false: If true, the cutoff distance might be different from dbulk and the density of the solvent in bulk will be estimated from the density within dbulk and cutoff. If false, the density of the solvent is estimated from the density outside dbulk by exclusion. Default: false. The definition of bulk_range instead is highly encouraged. \n\nirefatom: Integer, index of the reference atom in the solvent molecule used to compute the shell volumes and domain volumes in the Monte-Carlo volume estimates. The final rdf data is reported for this atom as well. By default, we choose the atom which is closer to the center of coordinates of the molecule, but any choice should be fine. \n\nn_random_samples: Integer, how many samples of random molecules are generated for each solvent molecule to compute the shell volumes and random MDDF counts. Default: 10. Increase this only if you have short trajectory and want to obtain reproducible results for that short trajectory. For long trajectories (most desirable and common), this value can even be decreased to speed up the calculations. \n\nseed: Seed for random number generator. If -1, the seed will be generated from the entropy of the system. If your results are dependent on the seed, is is probable that you do not have enough sampling. Mostly used for testing purposes. Two runs are only identical if ran with the same seed and in serial mode.   \n\nStableRNG (::Bool), defaults to false. Use a stable random number generator from the StableRNGs package, to produce identical runs on different architectures and Julia versions. Only used for testing. \n\nnthreads: How many threads to use. By default, it will be the number of physical cores of the computer.\n\nlcell: Integer, the cell length of the linked-cell method (actually the cell length is cutoff/lcell). Default: 1.  \n\nGC: Bool, force garbage collection, to avoid memory overflow. Default: true. That this might be required is probably a result of something that can vastly improved in memory management. This may slow down parallel runs significantly if the GC runs too often.\n\nGC_threshold: Float64, minimum fraction of the total memory of the system required to force a GC run. That is, if GC_threshold=0.1, which is the default, every time the free memory becomes less or equal to 10% of the total memory available, a GC run occurs.  ","category":"section"},{"location":"options/#Frame-statistical-reweighing","page":"Options","title":"Frame statistical reweighing","text":"compat: Compat\nFrame reweighing is available in ComplexMixtures 2.0.0 or greater.\n\nMost times the weights of each frame of the trajectory are the same, resulting from some standard MD simulation. If, for some reason, the frames have  different statistical weights, the weights can be passed to the as an  optional parameter frame_weights.\n\nFor example:\n\njulia> results = mddf(trajectory_file, solute, solvent, options; frame_weights=[0.0, 1.0, 2.0])\n\nThe code above will assign a larger weight to the third frame of the trajectory. These weights are relative (meaning that [0.0, 1.0, 2.0] would produce  the same result). What will happen under the hood is that the distance counts of the frames will be multiplied by each frame weight, and normalized for the sum of the weights.\n\nImportant: The length of the frame_weights vector must be at least equal to the number of the last frame read from the trajectory. That is, if lastframe  is not set, and all the frames will be read, the length of frame_weights must be equal to the length of the trajectory (the stride parameter will skip the information both of the frames and its weights). If lastframe is set, then the length of frame_weights must be at least lastframe (it can be greater, and further values will be ignored). Importantly, the indices of the elements in frame_weights are assumed to correspond to the indices of the frames in the original trajectory file.","category":"section"},{"location":"options/#Compute-coordination-number-only","page":"Options","title":"Compute coordination number only","text":"For some systems, it may be impossible, or to expensive, to compute the normalization of the minimum-distance distribution function. Nevertheless, the coordination number may still be an interesting information to be retrieved from the  simulations. To run the computation to compute coordination numbers only, do:\n\njulia> results = mddf(trajectory_file, solute, solvent, options; coordination_number_only = true)\n\nnote: Note\nWith coordination_number_only set to true, the arrays associated to MDDFs and KB integrals will be empty in the output data structure. ","category":"section"},{"location":"options/#trajectories","page":"Options","title":"Loading trajectories","text":"note: Note\nThis explicit export of the Trajectory object is kept mostly for legacy compatibility (previous to v2.9.0).\n\nTo initialize a trajectory file for computation before calling the mddf or coordination_number functions, use the command\n\ntrajectory = Trajectory(\"trajectory.xtc\",solute,solvent)\n\nwhere solute and solvent are defined with the AtomSelection function  described before. This function opens the stream for reading frames, which are read once a time when the coordinates are required for computing the MDDF.\n\nThis object can be used to feed mddf and coordination_number with:\n\nmddf(trajectory, options)\ncoordination_number(trajectory, options)\n\nThe Trajectory function uses Chemfiles in background, and thus the most common trajectory formats are supported, as the ones produced with NAMD, Gromacs, LAMMPS, Amber, etc.  \n\ntip: Tip\nThe format of the trajectory file is automatically determined by Chemfiles from the extension of the file. However, it can be provided by the user with the format keyword, for example:trajectory = Trajectory(\"trajectory.xtc\",solute,solvent,format=\"xtc\")","category":"section"},{"location":"options/#Stop-a-computation","page":"Options","title":"Stop a computation","text":"To stop a running calculation without losing the Julia REPL state, add a file named\n\nstop_complexmixtures\n\nin the same directory from where the computation was launched. This will interrupt the  computations in each parallel task as soon as the file is detected. The partial results will be returned and are, thus, invalid. Remove the file to restart a calculation. The content of the file is not important, thus it can be created by the touch stop_complexmixtures linux command. \n\ncompat: Compat\nThe stop_complexmixtures feature was added in v2.12.0","category":"section"},{"location":"options/#ComplexMixtures.Options-Tuple{}","page":"Options","title":"ComplexMixtures.Options","text":"Options(;\n    firstframe::Int = 1,\n    lastframe::Int = -1,\n    stride::Int = 1,\n    irefatom::Int = -1,\n    n_random_samples::Int = 10,\n    binstep::Float64 = 0.02,\n    dbulk::Union{Nothing,Real} = nothing,\n    cutoff::Union{Nothing,Real} = nothing,\n    usecutoff::Union{Nothing,Bool} = nothing,\n    bulk_range=nothing,\n    lcell::Int = 1,\n    GC::Bool = true,\n    GC_threshold::Float64 = 0.3,\n    seed::Int = 321,\n    StableRNG::Bool = false,\n    nthreads::Int = 0,\n    silent::Bool = false\n)\n\nCreate an Options object with the specified options. \n\n\n\n\n\n","category":"method"},{"location":"options/#ComplexMixtures.Trajectory","page":"Options","title":"ComplexMixtures.Trajectory","text":"Trajectory(filename::String, solute::AtomSelection, solvent::AtomSelection; format::String = \"\", chemfiles = false)\n\nTrajectory constructor data type. \n\nDefaults to reading with the Chemfiles infrastructure, except for DCD and PDB trajectory files, if the \"PDBTraj\" option is provided.\n\nSee memory issue (https://github.com/chemfiles/Chemfiles.jl/issues/44)\n\n\n\n\n\n","category":"type"},{"location":"python/#python","page":"From Python","title":"From Python","text":"note: Note\nMost features of the package are available through this Python interface. However, some flexibility may be reduced and, also, the tuning of the plot appearance is left to the user, as it is expected that he/she is fluent with some tools within Python if choosing this interface.Python 3 or greater is required.Please report issues, incompatibilities, or any other difficulty in using the package and its interface.\n\nThe following examples consider a system composed a protein solvated by a mixture of water and glycerol, built with Packmol. The simulations were performed with NAMD with periodic boundary conditions and a NPT ensemble at room temperature and pressure. Molecular pictures were produced with VMD.\n\n<center>\n<img width=50% src=\"../figures/prot_glyc_system.png\">\n</center>\n\nImage of the system of the example: a protein solvated by a mixture of glycerol (green) and water, at a concentration of 50%vv.","category":"section"},{"location":"python/#Loading-the-ComplexMixtures.py-file","page":"From Python","title":"Loading the ComplexMixtures.py file","text":"The Python interface of ComplexMixtures is implemented in the ComplexMixtures.py file.  Just download it from the link and save it in a known path.","category":"section"},{"location":"python/#Installing-juliacall","page":"From Python","title":"Installing juliacall","text":"juliacall is a package that allows calling Julia programs from Python. Install it with\n\npip install juliacall","category":"section"},{"location":"python/#Installing-Julia-and-underlying-packages","page":"From Python","title":"Installing Julia and underlying packages","text":"Once juliacall is installed, from within Python, execute:\n\nimport ComplexMixtures\n\nhere we assume that the ComplexMixtures.py file is in the same directory where you launched Python.\n\nnote: Note\nOn the first time you execute this command, the Julia executable and the required Julia packages (ComplexMixtures and PDBTools) will be downloaded and installed. At the end of the process quit Python (not really required, but we prefer to separate the installation from the use of the module). ","category":"section"},{"location":"python/#Example","page":"From Python","title":"Example","text":"","category":"section"},{"location":"python/#Index","page":"From Python","title":"Index","text":"Data, packages, and execution\nMinimum-Distance Distribution function\nMDDF and KB integrals\nAtomic contributions to the MDDF","category":"section"},{"location":"python/#data-pythonexample","page":"From Python","title":"Data, packages, and execution","text":"The files required to run this example are:\n\nsystem.pdb: The PDB file of the complete system.\nglyc50_sample.dcd: A 30Mb sample trajectory file. The full trajectory can also be used, but it is a 1GB file.\n\nTo start, create a directory and copy the ComplexMixtures.py file to it. Navigate into this directory, and, to start, set the number of threads that Julia will use, to run the calculations in parallel. Typically, in bash, this means defining the following environment variable:\n\nexport JULIA_NUM_THREADS=8\n\nwhere 8 is the number of CPU cores available in your computer. For further information about Julia multi-threading, and on setting this environment variable in other systems, please read this section of the Julia manual.\n\nFinally, each script can be executed with, for example:\n\npython3 script.py","category":"section"},{"location":"python/#script1-python","page":"From Python","title":"Minimum-Distance Distribution function","text":"<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`python\n$(read(\"./assets/scripts/python/script1.py\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\nNote that the example here follows an identical syntax to the Julia example, except that we qualify the name of the loaded module and implicitly load the PDBTools package.\n\nThe script to compute the MDDFs as associated data from within python is, then:\n\nnote: Note\nTo change the options of the calculation, set the Options structure accordingly and pass it as a parameter to mddf. For example:options = cm.Options(bulk_range=(8.0, 12.0))\nresults = cm.mddf(trajectory_file, solute, solvent, options)The complete set of options available is described here.\n\nThe trajectory that was loaded was for a toy-example. The complete trajectory is available here, but it is a 3GB file. The same procedure above was performed with that file and produced the results_Glyc50.json file, which is available in the Data directory here. We will continue with this file instead. ","category":"section"},{"location":"python/#python-plotting1","page":"From Python","title":"MDDF and KB integrals","text":"The following python script will produce the typical MDDF and KB integral plot, for the sample system. The noise in the figures is because the trajectory sample is small.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`python\n$(read(\"./assets/scripts/python/script2.py\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )\n\nIn the top plot, we see that glycerol and water display clear solvation shells around the protein, with glycerol having a greater peak. This accumulation leads to a greater (less negative) KB integral for glycerol than water, as shown in the second plot. This indicates that the protein is preferentially solvated by glycerol in this system (assuming that sampling is adequate in this small trajectory).","category":"section"},{"location":"python/#python-plotting2","page":"From Python","title":"Atomic contributions to the MDDF","text":"The following script produces a plot of the group contributions of Glycerol to the total MDDF function. The Glycerol MDDF is split into the contributions of the hydroxyl and aliphatic groups.\n\n<details><summary><font color=\"darkgreen\">Complete example code: click here!</font></summary>\n\nusing Markdown\ncode = Markdown.parse(\"\"\"\n\\`\\`\\`python\n$(read(\"./assets/scripts/python/script3.py\", String))\n\\`\\`\\`\n\"\"\")\n\n</details><br>\n\n(Image: )\n\nDespite the low sampling, it is clear that hydroxyl groups contribute to the greter peak of the distribution, at hydrogen-bonding distances, as expected. The contributions of the aliphatic groups to the MDDF occurs at longer distances, associated to non-specific interactions. \n\nnote: Note\nThe syntax here diverges from the Julia-only examples by requiring the lists of names to be converted to Julia arrays, which happens by using the cm.list(python_list) function calls.","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"ComplexMixtures.jl is a package to study the solute and solvent interactions of mixtures of molecules of complex shape. Conventional radial distribution functions are not appropriate to represent the structure of a solvent around a solute with many atoms, and a variable, non-spherical shape.     \n\nTypical solutes of complex shape are proteins, nucleic acids, and polymers in general. Smaller molecules like lipids, carbohydrates, etc, are also complex enough such that representing the structure of the solution of those molecules with distribution functions is not trivial.\n\nMinimum-Distance Distribution Functions (MDDFs) are a very general and practical way to represent solute-solvent interactions for molecules with arbitrarily complex sizes and geometries. Briefly, instead of computing the density distribution function of a particular atom or the center-of-mass of the molecules, one computes the distribution function of the minimum-distance between any solute and solvent atoms. This provides a size and shape-independent distribution which is very natural to interpret in terms of molecular interactions.   \n\nAdditionally, the MDDFs can be decomposed into contributions of each type of atom (or groups of atoms) of the solute and solvent molecules, such that the profiles of the distributions can be interpreted in terms of the chemical nature of the species involved in the interactions at each distance.   \n\nFinally, as with radial distribution functions, MDDFs can be used to compute Kirkwood-Buff integrals to connect the accumulation or depletion of the solvents components to thermodynamic properties, like protein structural stability, solubility, and others.\n\ncompat: Compat\nImportant: This manual refers to version 2 of ComplexMixtures.jl. There are syntax changes relative to the 1.X series, and analysis scripts  written for the previous versions won't work. The list of changes necessary to updated the scripts is described here.","category":"section"},{"location":"#Help!","page":"Introduction","title":"Help!","text":"Please ask for help if having any difficulty using the package. Reach us by:\n\nAsking a question on the Julia Discourse forum. Please mark @lmiq on your post, otherwise we may miss it! This may be very effective to get help from  many Julia users on questions not directly related to physical-chemistry.\nOpening an issue if you think you found a problem in the package. Even documentation problems can be reported.\nJoining us at Zulip-chat in the m3g stream of the Julia Zulip forum.\nSending an e-mail to: lmartine@unicamp.br.","category":"section"},{"location":"#Features","page":"Introduction","title":"Features","text":"Check out our examples, featuring the analysis of solvation structures for proteins, polymers, membrane, and complex solutions! The examples are also described in our featured article.","category":"section"},{"location":"#1.-Minimum-distance-distribution-functions:-understanding-solvation-at-a-molecular-level","page":"Introduction","title":"1. Minimum-distance distribution functions: understanding solvation at a molecular level","text":"This figure illustrates one of the main features of minimum-distance distribution functions, by showing the distribution of DMF molecules at the surface of an polyacrylamide molecule. The direct interactions are evident by the peak at hydrogen-bonding distances and, additionally, the contribution of each group of atoms of the DMF can be clearly distinguished by decomposing the total MDDF into atomic or chemical group contributions. \n\n<center>\n<img width=60% src=\"./figures/mddf_groups.png\">\n<br>\n<b>Minimum distance distribution function and its decomposition into the chemical\ngroups of the solvent (top) and solute (bottom) molecules.<br><br></b> \n</center>\n\nDecomposition of the total MDDF into the contributions of the solute atoms (in this case, a protein) is also possible. Any chemical group decomposition is possible. Here, we decompose the MDDF into the contribution of each protein residue. \n\n<center>\n<img width=70% src=\"./figures/density2D.png\">\n<br>\n<b>Density map of a solvent in the vicinity of each protein residue.</b> \n</center>","category":"section"},{"location":"#2.-Thermodynamic-interpretation-through-Kirkwood-Buff-theory","page":"Introduction","title":"2. Thermodynamic interpretation through Kirkwood-Buff theory","text":"Minimum-distance distribution functions can be used to compute Kirkwood-Buff integrals, and thus, thermodynamic parameters associated to solvation. \n\nKirkwood-Buff integrals carry the information of the total accumulation or depletion of each solvent around a solute. For example, the figure below displays the KB integrals of an ionic liquid solvating different conformational states of a protein [link]. The figure illustrates that the solvation structures are dependent on the protein folding state. \n\n<center>\n<img width=\"50%\" src=\"./figures/KBs.png\">\n<br>\n<b>Kirkwood-Buff integrals of an ionic liquid solvating a protein in different conformational states.</b><br><br> \n</center>\n\nFrom differences in KB integrals among cosolvents, the Preferential Solvation parameter can be computed. This is an important parameter because it can be measured experimentally and is ultimately associated with the equilibrium thermodynamics of the solvation. In the following figure, we show that, for example, the preferential solvation of a protein in different folding states is dependent in a non-trivial way on the concentration of an ionic liquid in aqueous solutions. \n\n<center>\n<img width=\"50%\" src=\"./figures/Gamma.png\">\n<br>\n<b>Preferential interaction parameters obtained for the solvation of a protein by ionic liquids.</b><br><br>\n</center>\n\nIn particular, the plot shows that besides being preferentially excluded from the protein surface at high concentrations in the native state, suggesting protein folding stabilization, the interactions with the protein in the denatured states are stronger, leading to denaturation at all concentrations. ","category":"section"},{"location":"#References","page":"Introduction","title":"References","text":"Please cite the following articles if the package was useful to you:\n\nL. Martínez, ComplexMixtures.jl: Investigating the structure of solutions of complex-shaped molecules from a solvent-shell perspective. J. Mol. Liq. 347, 117945, 2022. [Full Text]\nL. Martínez, S. Shimizu, Molecular interpretation of preferential interactions in protein solvation: a solvent-shell perspective by means of minimum-distance distribution functions. J. Chem. Theor.  Comp. 13, 6358–6372, 2017. [Full Text]","category":"section"},{"location":"#See-also","page":"Introduction","title":"See also","text":"","category":"section"},{"location":"#Seminar","page":"Introduction","title":"Seminar","text":"Presentation about ComplexMixtures.jl and protein-solvent interactions: https://youtu.be/umSRjsITzyA","category":"section"},{"location":"#Applications","page":"Introduction","title":"Applications","text":"A. F. Pereira, L. Martínez, Osmolyte Structural and Thermodynamic Effects Across the Protein Folding Landscape, JACS Au, 2025. [Full Text]. \n\n<a href=\"https://pubs.acs.org/toc/jpcbfk/129/27\"><img style=\"float: right\" src=\"assets/2025_jpcb_capa.png\" width=\"20%\"></a>\n\nV. Piccoli, L. Martínez, Cation Hydrophobicity Effects on Protein Solvation in Aqueous Ionic Liquids, J. Phys. Chem. B, 129 (27) 6765-6776, 2025. [Full Text]. \nF. C. Ramos, L. Martínez, Molecular dynamics and solvation structures of the β-glucosidase from Humicola insolens (BGHI) in aqueous solutions containing glucose Int. J. Biol. Macromol. 286 (138210) 2025. [Full Text]\nV. Piccoli, L. Martínez, Competitive Effects of Anions on Protein Solvation by Aqueous Ionic Liquids.  J. Phys. Chem. B 128, 7792-7802, 2024. [Full Text]\nA. F. Pereira, L. Martínez, Helical Content Correlations and Hydration Structures of the Folding Ensemble of the B Domain of Protein A. J. Chem. Inf. Model. 64, 3350-3359, 2024. [Full Text]\nA. F. Pereira, V. Piccoli, L. Martínez, Trifluoroethanol direct interactions with protein backbones destabilize alpha-helices.  J. Mol. Liq. 365, 120209, 2022. [Full Text]\nV. Piccoli, L. Martínez, Ionic liquid solvation of proteins in native and denatured states.  J. Mol. Liq. 363, 119953, 2022. [Full Text]\nV. Piccoli, L. Martínez, Correlated counterion effects in the solvation of proteins by ionic-liquids. J. Mol. Liq. 320, 114347, 2020. [Full Text]\nI. P. de Oliveira, L. Martínez, The shift in urea orientation at protein surfaces at low pH is compatible with a direct mechanism of protein denaturation. Phys. Chem. Chem. Phys. 22, 354-367, 2020. [Full Text]\nI. P. de Oliveira, L. Martínez, Molecular basis for competitive solvation of the Burkholderia cepacia lipase by sorbitol and urea. Phys. Chem. Chem. Phys. 18, 21797-21808, 2016. [Full Text]","category":"section"}]
}
